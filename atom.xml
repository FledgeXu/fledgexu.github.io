<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>曳东搬西</title>
  
  
  <link href="http://blog.otakusaikou.com/atom.xml" rel="self"/>
  
  <link href="http://blog.otakusaikou.com/"/>
  <updated>2021-03-25T03:58:48.735Z</updated>
  <id>http://blog.otakusaikou.com/</id>
  
  <author>
    <name>Fledge Shiu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IPFS 官方中文 Wikipedia 使用指南</title>
    <link href="http://blog.otakusaikou.com/2021/03/25/offical-wikipedia-ipfs-mirror-guide/"/>
    <id>http://blog.otakusaikou.com/2021/03/25/offical-wikipedia-ipfs-mirror-guide/</id>
    <published>2021-03-25T10:13:43.000Z</published>
    <updated>2021-03-25T03:58:48.735Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-IPFS？"><a href="#什么是-IPFS？" class="headerlink" title="什么是 IPFS？"></a>什么是 IPFS？</h2><blockquote><p><strong>星际文件系统</strong>（<strong>InterPlanetary File System</strong>，缩写<strong>IPFS</strong>）是一个旨在创建持久且分布式存储和共享文件的<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">网络传输协议</a>。它是一种<a href="https://zh.wikipedia.org/w/index.php?title=%E5%86%85%E5%AE%B9%E5%8F%AF%E5%AF%BB%E5%9D%80&action=edit&redlink=1">内容可寻址</a>的<a href="https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%AD%89%E7%B6%B2%E8%B7%AF">对等</a><a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E5%AA%92%E9%AB%94">超媒体</a>分发协议。在IPFS网络中的节点将构成一个<a href="https://zh.wikipedia.org/wiki/%E9%9B%86%E7%BE%A4%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">分布式文件系统</a>。它是一个<a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E6%94%BE%E6%BA%90%E4%BB%A3%E7%A0%81">开放源代码</a>项目，自2014年开始由<a href="https://zh.wikipedia.org/w/index.php?title=Protocol_Labs&action=edit&redlink=1">Protocol Labs</a>在开源社区的帮助下发展。其最初由<a href="https://zh.wikipedia.org/w/index.php?title=Juan_Benet&action=edit&redlink=1">Juan Benet</a>设计。</p></blockquote><p>用最简单的话来说 IPFS 是个 P2P网络，和我们日常可能会使用的 BT 下载的原理类似，但是 IPFS 相比于 BT 来说做了非常多的改进，使得 IPFS 的性能和扩展性都有很大的提升。</p><p>在 IPFS 网络中每一个文件都有一个独特的 CID，当你把一个文件放入 IPFS 网络中，其他的用户就可以通过 CID 来获取到这个文件而不必考虑这个文件存放在何处。此外任何用户可以选择 pin 住一个文件的 CID，从而帮助 IPFS 网络长期的保存某个文件。</p><h2 id="什么是-Distributed-Wikipedia-Mirror？"><a href="#什么是-Distributed-Wikipedia-Mirror？" class="headerlink" title="什么是 Distributed Wikipedia Mirror？"></a>什么是 Distributed Wikipedia Mirror？</h2><p><a href="https://github.com/ipfs/distributed-wikipedia-mirror">Distributed Wikipedia Mirror</a> 是 IPFS 官方团队维护的一个项目。这个项目旨在于将 Wikipedia 带入 IPFS 网络，以及最终构建出一个纯分布式的 Wikipedia。目前该项目已经提供了：英语、土耳其语、缅甸语和中文的 Wikipedia 镜像。</p><h2 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h2><p>本文将介绍如何使用中文版的 Wikipedia IPFS镜像。</p><p>镜像的地址为:</p><ul><li>DNSLink: <code>zh.wikipedia-on-ipfs.org</code></li><li>CID: <code>bafybeiazgazbrj6qprr4y5hx277u4g2r5nzgo3jnxkhqx56doxdqrzms6y</code></li></ul><p><strong>请注意本项目的 CID 地址会随着分发的 Wikipedia 镜像版本更新而改变，你可以通过访问<a href="https://github.com/ipfs/distributed-wikipedia-mirror/blob/main/snapshot-hashes.yml">此地址</a>或者使用 <code>ipfs name resolve zh.wikipedia-on-ipfs.org</code> 获取到最新的 CID</strong></p><p>我接下来会介绍3种不同的方式来访问本镜像。</p><hr><h3 id="公共网关"><a href="#公共网关" class="headerlink" title="公共网关"></a>公共网关</h3><p>公共网关是目前访问 IPFS 网络上内容最简单的方式，但这个也是最容易被封锁的方式。我将以官方的网关为例来演示如何使用公共网关来访问 IPFS 网络上的内容。</p><p><strong>官方公共网关地址: <code>https://ipfs.io</code></strong></p><h4 id="使用-CID-访问镜像"><a href="#使用-CID-访问镜像" class="headerlink" title="使用 CID 访问镜像"></a>使用 CID 访问镜像</h4><p>如果你决定使用 CID 地址来访问镜像的话，你需要在浏览器地址栏按照如下格式输入:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://ipfs.io/ipfs/&lt;CID&gt;</span><br></pre></td></tr></table></figure><p>在我们的例子里就是：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://ipfs.io/ipfs/bafybeiazgazbrj6qprr4y5hx277u4g2r5nzgo3jnxkhqx56doxdqrzms6y</span><br></pre></td></tr></table></figure><h4 id="使用-DNSLink-地址访问"><a href="#使用-DNSLink-地址访问" class="headerlink" title="使用 DNSLink 地址访问"></a>使用 DNSLink 地址访问</h4><p>如果你决定使用 DNSLink 地址来访问镜像的话，你需要在浏览器地址栏按照如下格式输入:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://ipfs.io/ipns/&lt;DNSLink&gt;</span><br></pre></td></tr></table></figure><p>在我们的例子里就是：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://ipfs.io/ipns/zh.wikipedia-on-ipfs.org</span><br></pre></td></tr></table></figure><hr><h3 id="Brave-浏览器"><a href="#Brave-浏览器" class="headerlink" title="Brave 浏览器"></a>Brave 浏览器</h3><p>如果你在使用最新版的 <a href="https://brave.com/">Brave 浏览器</a>，你可以直接使用 Brave 内置的 IPFS 节点来访问 IPFS 网络上的内容。你在第一次使用 Brave 浏览器访问 IPFS 内容时，Brave 浏览器可能会询问你是否要启用本地 IPFS 节点，建议选择启用，如果没有启用，Brave 会自动使用公共网关来访问 IPFS 网络上的内容。此外你可以通过 Brave 设置页面中 IPFS 相关的选项和内置的 IPFS-Companion 插件中的选项来调整 IPFS 节点类型。</p><h4 id="使用-CID-访问镜像-1"><a href="#使用-CID-访问镜像-1" class="headerlink" title="使用 CID 访问镜像"></a>使用 CID 访问镜像</h4><p>如果你决定使用 CID 地址来访问镜像的话，你需要在浏览器地址栏按照如下格式输入:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipfs://&lt;CID&gt;</span><br></pre></td></tr></table></figure><p>在我们的例子里就是：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipfs://bafybeiazgazbrj6qprr4y5hx277u4g2r5nzgo3jnxkhqx56doxdqrzms6y</span><br></pre></td></tr></table></figure><h4 id="使用-DNSLink-地址访问-1"><a href="#使用-DNSLink-地址访问-1" class="headerlink" title="使用 DNSLink 地址访问"></a>使用 DNSLink 地址访问</h4><p>如果你决定使用 DNSLink 地址来访问镜像的话，你需要在浏览器地址栏按照如下格式输入:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipns://&lt;DNSLink&gt;</span><br></pre></td></tr></table></figure><p>在我们的例子里就是：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipns://zh.wikipedia-on-ipfs.org</span><br></pre></td></tr></table></figure><hr><h3 id="IPFS-Desktop"><a href="#IPFS-Desktop" class="headerlink" title="IPFS Desktop"></a>IPFS Desktop</h3><p>IPFS Desktop 对于是目前普通用户使用本地 IPFS 最容易的方法，你可以在<a href="https://github.com/ipfs-shipyard/ipfs-desktop/releases/latest">这里</a>下载最新版的 IPFS Desktop。在启动成功之后， IPFS-Dekstop 会默认在你本地地址的 <code>8080</code> 端口启动一个网关服务器，之后我们就可以使用这个本地的网关服务来访问 IPFS 网络上的内容了。</p><p>当然你可以通过修改 IPFS-Desktop 中的 <code>Gateway</code> 项，来修改默认的端口地址。</p><h4 id="使用-CID-访问镜像-2"><a href="#使用-CID-访问镜像-2" class="headerlink" title="使用 CID 访问镜像"></a>使用 CID 访问镜像</h4><p>如果你决定使用 CID 地址来访问镜像的话，你需要在浏览器地址栏按照如下格式输入:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:&lt;port&gt;/ipfs/&lt;CID&gt;</span><br></pre></td></tr></table></figure><p>在我们的例子里就是：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8080/ipfs/bafybeiazgazbrj6qprr4y5hx277u4g2r5nzgo3jnxkhqx56doxdqrzms6y</span><br></pre></td></tr></table></figure><h4 id="使用-DNSLink-地址访问-2"><a href="#使用-DNSLink-地址访问-2" class="headerlink" title="使用 DNSLink 地址访问"></a>使用 DNSLink 地址访问</h4><p>如果你决定使用 DNSLink 地址来访问镜像的话，你需要在浏览器地址栏按照如下格式输入:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:&lt;port&gt;/ipns/&lt;DNSLink&gt;</span><br></pre></td></tr></table></figure><p>在我们的例子里就是：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8080/ipns/zh.wikipedia-on-ipfs.org</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是-IPFS？&quot;&gt;&lt;a href=&quot;#什么是-IPFS？&quot; class=&quot;headerlink&quot; title=&quot;什么是 IPFS？&quot;&gt;&lt;/a&gt;什么是 IPFS？&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;星际文件系统&lt;/strong&gt;（&lt;stro</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>如何使用IPFS版的中文Wikipedia</title>
    <link href="http://blog.otakusaikou.com/2021/02/22/how-to-use-wikipedia-on-ipfs/"/>
    <id>http://blog.otakusaikou.com/2021/02/22/how-to-use-wikipedia-on-ipfs/</id>
    <published>2021-02-22T15:25:48.000Z</published>
    <updated>2021-03-25T03:58:48.731Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文内容已经废弃，请参照最新的《IPFS 官方中文 Wikipedia 使用指南》</strong></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>如果你熟悉 IPFS 的话，以下是地址</p><p>CID: <code>bafybeierrdxblmthjga6wap3tpk53icgzb7owstz5gbd6qxcy3kspktymm</code><br>IPNS: <code>k51qzi5uqu5dirl3inwnhrl6nicsaq9snlzg2aj7blt2komssvff4c9ln8tch3</code></p><h4 id="这是什么？"><a href="#这是什么？" class="headerlink" title="这是什么？"></a>这是什么？</h4><p>简单来说这是个用IPFS运行的中文版 Wikipedia 的镜像，这里的镜像用的是 Kiwix 提供的 <code>wikipedia_zh_all_maxi_2021-01</code> 版本镜像。IPFS 是一个类似 BT 的分布式文件系统，具体的介绍可以参照 Wikipedia 的「星际文件系统」条目。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>接下来的我会介绍三种使用方法，难度从易到难。</p><h4 id="公共网关"><a href="#公共网关" class="headerlink" title="公共网关"></a>公共网关</h4><p>目前来说使用公共网关来访问 IPFS 上的内容是最为简单的方法。</p><p>首先你需要找到一个公共网关的地址，我们以 IPFS 官方提供的公共网关举例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;ipfs.io</span><br></pre></td></tr></table></figure><p>接下来看你需要访问 CID 的内容还是 IPNS 的内容</p><p>如果是 CID：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;ipfs.io&#x2F;ipfs&#x2F;bafybeierrdxblmthjga6wap3tpk53icgzb7owstz5gbd6qxcy3kspktymm</span><br></pre></td></tr></table></figure><p>如果是 IPNS:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;ipfs.io&#x2F;ipns&#x2F;k51qzi5uqu5dirl3inwnhrl6nicsaq9snlzg2aj7blt2komssvff4c9ln8tch3</span><br></pre></td></tr></table></figure><p>当然官方提供的公共网关已经被墙了，你可以在访问<a href="https://contributionls.github.io/public-gateway-checker/?cid=bafybeierrdxblmthjga6wap3tpk53icgzb7owstz5gbd6qxcy3kspktymm">这里</a>寻找没有被墙的公共网关。</p><h4 id="Brave-浏览器"><a href="#Brave-浏览器" class="headerlink" title="Brave 浏览器"></a>Brave 浏览器</h4><p>目前 Brave 浏览器原生支持了 IPFS 链接，使用 Brave 浏览器访问 IPFS 上的内容也很简单。</p><p>首先你需要<a href="https://brave.com/">下载</a> Brave 浏览器，然后下载完成后，在你的地址栏里输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipfs:&#x2F;&#x2F;bafybeierrdxblmthjga6wap3tpk53icgzb7owstz5gbd6qxcy3kspktymm</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipns:&#x2F;&#x2F;k51qzi5uqu5dirl3inwnhrl6nicsaq9snlzg2aj7blt2komssvff4c9ln8tch3</span><br></pre></td></tr></table></figure><p>第一次访问 IPFS 的链接 Brave 可能会问你要不要使用本地 IPFS 节点，建议选择使用，如果不使用本地节点，Brave 会自动 fallback 到公共网关。</p><h4 id="IPFS-Desktop"><a href="#IPFS-Desktop" class="headerlink" title="IPFS-Desktop"></a>IPFS-Desktop</h4><p>IPFS-Desktop 是 IPFS 官方开发的一款 IPFS 的图形化操作软件，你可以在<a href="https://github.com/ipfs-shipyard/ipfs-desktop/releases/latest">这里</a>下载到最新版。</p><p>在你下载启动 IPFS-Desktop 之后，IPFS 会自动监听<code>127.0.0.1:8080</code>作为本地的网关。</p><p>所以你可以打开你日常使用的浏览器输入（你可以安装 <a href="https://github.com/ipfs-shipyard/ipfs-companion">IPFS- Companion</a> 插件来方便访问）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;ipfs&#x2F;bafybeierrdxblmthjga6wap3tpk53icgzb7owstz5gbd6qxcy3kspktymm</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;ipns&#x2F;k51qzi5uqu5dirl3inwnhrl6nicsaq9snlzg2aj7blt2komssvff4c9ln8tch3</span><br></pre></td></tr></table></figure><p>来访问。</p><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><p>本中文 Wikipedia 只是一个静态的镜像，无法添加新的内容，另外目前也不支持搜索功能。不过你可以通过自己改变URL来访问不同的页面，比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipfs:&#x2F;&#x2F;bafybeierrdxblmthjga6wap3tpk53icgzb7owstz5gbd6qxcy3kspktymm&#x2F;wiki&#x2F;计算机科学</span><br></pre></td></tr></table></figure><p>你只需要改变链接 <code>wiki</code> 后面的名字就能访问不同的页面。</p><h2 id="这个项目是如何持续的？"><a href="#这个项目是如何持续的？" class="headerlink" title="这个项目是如何持续的？"></a>这个项目是如何持续的？</h2><p>这个项目是完全免费的，现在也是之后也是，随着用户的增多这个项目消失的可能性也就越小。如果你愿意帮助分发本项目或者想自己建立一个镜像请看之后的链接。但是目前维护这个项目每个月还是会有一定的成本。目前这个成本我可以自己承担，另外我也持有了一定的 FileCoin（IPFS 上层的激励币，另外这个不是投资建议，请不要盲目投资加密货币），如果你希望这个项目可以长期维持，我非常建议你了解甚至开发 IPFS 相关的项目，这样我手上的 FileCoin 就可以升值了，也就可以抵消相关的成本了。</p><p>另外我也接受虚拟货币的捐款。</p><p>FileCoin 捐款地址: <code>f1sbsblwklyr4drmi3ajzez5vglgvpwxudgtuyqqy</code></p><h2 id="如何帮助分发和如何建立自己的镜像"><a href="#如何帮助分发和如何建立自己的镜像" class="headerlink" title="如何帮助分发和如何建立自己的镜像"></a>如何帮助分发和如何建立自己的镜像</h2><p>请参照我写的<a href="https://blog.otakusaikou.com/2021/02/09/wikipedia-on-ipfs-tutorial/">另一篇文章</a>.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;本文内容已经废弃，请参照最新的《IPFS 官方中文 Wikipedia 使用指南》&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;如果你熟</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>如何在IPFS上部署Wikipedia</title>
    <link href="http://blog.otakusaikou.com/2021/02/09/wikipedia-on-ipfs-tutorial/"/>
    <id>http://blog.otakusaikou.com/2021/02/09/wikipedia-on-ipfs-tutorial/</id>
    <published>2021-02-09T17:33:19.000Z</published>
    <updated>2021-03-25T03:58:48.771Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在 IPFS 上部署 Wikipedia 的原理相当的简单，主要利用了 <a href="https://wiki.kiwix.org/wiki/Main_Page/zh-cn">Kiwix</a> 提供的离线版 Wikipedia 文件，将其解压并转换成静态文件之后就可以放到 IPFS 上了。这里我们主要依靠了 IPFS 团队提供的 <a href="https://github.com/ipfs/distributed-wikipedia-mirror">distributed-wikipedia-mirror</a> 项目以及 OpenZIM 团队提供的 <a href="https://github.com/openzim/zim-tools">ZIM-Tools</a> 工具，同样也非常感谢 IPFS 和 OpenZIM 团队在我折腾过程中给我提供的帮助。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>目前来说整个过程只能在 AMD64 Linux 上完成，主要是 ZIM-Tools 项目目前还没有在其他系统下的构建。我们将以中文版的 Wikipedia 为例。这个过程大概会消耗你大约 90G 左右的空间，所以请至少保证你的磁盘有大约 100G 左右的余量，此外这个大小会随着中文 Wikipedia 的内容增加而增长，另外你还在保证你的部署系统有至少4G的内存（我不清楚调整OOM相关的设置可不可以缓解这个问题，从而实现在小容量内存上的使用，不过我还是建议加大内存）。</p><p>首先你肯定需要一个 IPFS 的节点，这里不介绍 IPFS 节点的搭建了。除此之外为了能在 IPFS 托管 Wikiepedia，我们还需要启用几个IPFS的实验特性，这里我们以 <code>go-ipfs</code> 作为 IPFS 节点软件。</p><p>你可以通过<code>IPFS_PATH</code>环境变量来指定IPFS仓库的位置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> IPFS_PATH=/somewhere</span><br></pre></td></tr></table></figure><p>其次建议使用 <code>badgerds</code>数据来存放数据，从而提升性能</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipfs init -p badgerds --empty-repo</span><br></pre></td></tr></table></figure><p>首先我们需要启用 <code>Experimental.ShardingEnabled</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipfs config --json <span class="string">&#x27;Experimental.ShardingEnabled&#x27;</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这个选项解除了一个文件夹内可以存放文件数量的限制，你可以在<a href="https://github.com/ipfs/go-ipfs/blob/master/docs/experimental-features.md">这个页面</a>找到 <code>go-ipfs</code> 的所有实验性特性的说明和配置。</p><p>然后你得保证你的电脑上安装了 <code>Cargo</code>、<code>Nodejs</code>、<code>yarn</code>、<code>git</code>以及一系列的构建工具（也就是 Debian 系的 <code>build-essential</code> 包中的工具）。</p><p>接下来你需要克隆并且进入 <a href="https://github.com/ipfs/distributed-wikipedia-mirror">distributed-wikipedia-mirror</a>  项目。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/ipfs/distributed-wikipedia-mirror &amp;&amp; <span class="built_in">cd</span> distributed-wikipedia-mirror</span><br></pre></td></tr></table></figure><p>然后输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn</span><br></pre></td></tr></table></figure><p>来构建配置环境。</p><p>因为我们之后需要用到 <a href="https://github.com/openzim/zim-tools">ZIM-Tools</a> 来解压我们下载完成的 ZIM 文件，所以我们预先下载好 ZIM-Tools，这里我们以 2.1.0 为例，你可以在这里找到 ZIM-Tools 预编译的二进制包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.openzim.org/release/zim-tools/zim-tools_linux-x86_64-2.1.0.tar.gz</span><br><span class="line">tar -xf zim-tools_linux-x86_64-2.1.0.tar.gz</span><br><span class="line">mv zim-tools_linux-x86_64-2.1.0 zim</span><br></pre></td></tr></table></figure><p>接下来需要下载 ZIM 文件，ZIM 文件是一种离线版 Wikipedia 保存格式。</p><p> <a href="https://github.com/ipfs/distributed-wikipedia-mirror">distributed-wikipedia-mirror</a> 项目默认提供了一种直接下载的方式，你可以输入:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash ./tools/getzim.sh cache_update</span><br><span class="line">bash ./tools/getzim.sh choose</span><br></pre></td></tr></table></figure><p>进入选择菜单输入数字选择，比如你要中文版的全量 Wikipedai 的 ZIM文件，你可以选择<code>[12] wikipedia =&gt; [294] zh =&gt; [0] all =&gt; [0] maxi =&gt; [0] latest</code> 来获取到最新的中文 Wikipedia 全量 ZIM 文件，下载完成后默认存放在  <code>snapshots</code> 文件夹中。</p><p>当然因为下载服务在海外，如果你想在国内的机器上配置的话，我更推荐使用 BitTorrent 的方式来下载，这里我们将以 <code>wikipedia_zh_all_maxi_2021-01.zim</code> 为例，你可以<a href="https://wiki.kiwix.org/wiki/Content_in_all_languages">在这里</a>获取到所有语言的 BitTorrent 种子文件。</p><p>为了方便起见我们这里直接使用了<code>aria2</code> 来进行 BitTorrent 下载。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.kiwix.org/zim/wikipedia_zh_all_maxi.zim.torrent </span><br><span class="line">aria2c wikipedia_zh_all_maxi.zim.torrent -d snapshots</span><br></pre></td></tr></table></figure><p>在下载完毕之后我们需要解压 zim 文件，在我们的例子里就是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir tmp</span><br><span class="line">./zim/zimdump dump ./snapshots/wikipedia_zh_all_maxi_2021-01.zim --dir ./tmp/wikipedia_zh_all_maxi_2021-01</span><br></pre></td></tr></table></figure><p>这个解压过程会很漫长，并且会消耗大量的磁盘空间，以我的体验来说，zim文件的压缩比大概是 4:1，也就是 1G 的 ZIM 文件大概会解压出 4G 的原始文件。</p><p>在解压完毕之后，我们还需要稍微处理一下解压好的文件，这样才能让用户正常的浏览网页。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node ./bin/run ./tmp/wikipedia_zh_all_maxi_2021-01 \</span><br><span class="line">  --zimfilesourceurl=https://download.kiwix.org/zim/wikipedia_zh_all_maxi.zim \</span><br><span class="line">  --kiwixmainpage=User:The_other_Kiwix_guy/Landing \</span><br><span class="line">  --mainpage=Wikipedia:%E9%A6%96%E9%A1%B5</span><br></pre></td></tr></table></figure><p>这里的 <code>--zimfilesourceurl</code>、<code>--kiwixmainpage</code>、<code>--mainpage</code> 是三个必须选项，这里还有其他的选择可以选择，你可以输入如下命令查看所有的选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node ./bin/run -h</span><br></pre></td></tr></table></figure><p>上面我们填的三个参数的作用分别是</p><ul><li><code>--zimfilesourceurl</code>：指定 ZIM 文件的下载地址</li><li><code>--kiwixmainpage</code>：Kiwix 的默认主页是什么，中文 Wikipedia 这里的值是 <code>User:The_other_Kiwix_guy/Landing</code></li><li><code>--mainpage</code>：网页版 Wikipedia 的默认主页是什么，中文 Wikipedia 这里的值是<code>Wikipedia:%E9%A6%96%E9%A1%B5</code></li></ul><p>之后应该就会在之前的解压目录中生成<code>index.html</code>等文件，来让用户可以向访问正常网页一样访问了。</p><p>在添加文件之前我们需要提升一下系统的可打开文件数量，不然中途会失败。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ulimit -a</span><br><span class="line">ulimit -n 8096</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipfs add -r --cid-version 1 ./tmp/wikipedia_zh_all_maxi_2021-01/</span><br></pre></td></tr></table></figure><p>这个过程可能会持续大约50个小时（我的部署），建议用类似<code>screen</code>的软件保证部署不会中断。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;p&gt;在 IPFS 上部署 Wikipedia 的原理相当的简单，主要利用了 &lt;a href=&quot;https://wiki.kiwix.org/wi</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>命名数据网络，一个未来网络的可能性</title>
    <link href="http://blog.otakusaikou.com/2021/01/19/named-data-networking-a-feature-network/"/>
    <id>http://blog.otakusaikou.com/2021/01/19/named-data-networking-a-feature-network/</id>
    <published>2021-01-19T19:35:48.000Z</published>
    <updated>2021-03-25T03:58:48.735Z</updated>
    
    <content type="html"><![CDATA[<p>我们的故事要回到 1974 年，彼时计算机主要形式还是大型机，创造计算机行业历史的 Apple I 要在两年后才正式面世，而我们熟知的万维网（World Wide Web）在整整十五年后才会被伯纳斯-李爵士在他的《关于信息化管理的建议》中提出。在那时我们现在使用的互联网还未出现，当时有的只是「阿帕网」——一个仅有4个节点构成的小型网络。而在 1973 的夏天到 1974 年的这段时间，来自康涅狄格州和出身自纽约的犹太人家庭的两位年轻人，他们在斯坦福的网络研究组里设计和开发出了一个叫做 <strong>TCP/IP</strong> 协议。正如上帝要把祂的教会建立在磐石之上在，TCP/IP 协议最后也成了我们网络世界的「磐石」。这两位年轻人：文顿·瑟夫和罗伯特·卡恩，也在三十年后的 2004 年，获得了计算机科学领域最贵重的那只碗——图灵碗。</p><p>当然我们的故事还要继续，在几乎同一时期的中国大陆，一位叫做张丽霞的年轻女性受到了文革的影响，正在田野中开着拖拉机。她在文革结束后来到了美国，并在美国获取了硕士和博士学位。后来她在 1986 年作为 21 人中唯一的女性和唯一还是学生身份的人的参加了第一次的互联网工程任务组会议。而这个「小组」最后成长为了一个负责互联网规范制定与研发的庞大组织。在几年后范·雅各布森， TCP/IP 协议最初的起草者中的其中一位，重新设计了 TCP/IP 的流控制算法，并和他人一起合作编写了一系列如今软件工程师们仍在使用的网络工具：traceroute、pathchar 以及 tcpdump。在 2006 年 8 月的 Google Tech Talk 上做了一个叫做《<a href="https://www.youtube.com/watch?v=oCZMoY3q2uM">A New Way to look at Networking</a>》的演讲，在这个演讲中，他提出了一个名叫「Named Data Networking」的全新的网络架构，并在此后的多年里和张丽霞教授一起领导着这个项目的研究。而这个项目正是我们今天的主角：命名数据网络，简称 NDN 网络。</p><p>为了理解什么是命名数据网络，以及命名数据网络为什么重要，我们得先理解现有的 TCP/IP 网络的模型是什么样子的，我们先从 TCP/IP 网络的定义着手。</p><blockquote><p>TCP/IP 提供了点对点连结的机制，将资料应该如何封装、定址、传输、路由以及在目的地如何接收，都加以标准化。</p><p>——<a href="https://zh.wikipedia.org/zh-hans/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F">Wikipedia</a></p></blockquote><p>这句话中的「点对点」的意思是，在 TCP/IP 模型中，设备获取内容的主要方式是从另一台计算机那里下载。当然这么说还是很复杂，我们来看一个详细的例子。</p><p>首先我们要明白，在 TCP/IP 模型中，在一个网络中每一个计算机都有一个独属于它的 IP 地址，而计算机则是用 IP 地址来表联系网络中另一台计算机。任意一台计算机上的资源都可以表示为下面的形式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file:&#x2F;&#x2F;119.23.141.248&#x2F;index.html</span><br></pre></td></tr></table></figure><p>上面描述了一台 IP 地址为 <code>119.23.141.248</code> 的计算机上的一个叫做 <code>index.html</code> 的文件，这里的 <code>file://</code> 只是一个前缀标识而已，不用过于在意。而其他的计算机要获取这个文件必须要向这台计算机发送请求，与这台计算机建立一个传输数据的通道，然后才能开始正式传输数据。</p><p>可以看到在 TCP/IP 模型中，IP 地址是寻找内容时的核心，而「通道」则是传输内容的核心。但是如果你仔细想想，我们想要的只是获取获取到这个 <code>index.html</code> 文件而已，其实并不想也并不需要关心这个文件具体存放在什么地方。而我们也不想关心通道，我们只是想要内容而已。</p><p>那么这个模型有什么问题呢？想象下面这个情况。</p><p><img src="image-20210119184048547.png" alt="多台计算机连接同一台计算机获取同一个资源文件"></p><p>在上面这张图中，描绘了一个多个计算机访问一台计算机上内容的情况。在这个过程中，虽然下方的每台计算机都是想要获取同一个 <code>index.html</code> 文件，但是他们都需要访问这台地址为 <code>119.23.141.248</code> 的计算机并与这台计算机建立通道。这会重复的消耗这台计算机的网络资源，这显然是不高效的。而访问同一个文件会重复消耗计算机资源现象，也导致了现在网络世界中 DDOS 攻击泛滥。</p><p>最糟糕的是下面这种情况。</p><p><img src="image-20210119184128701.png" alt="偷窥者正在偷窥通道"></p><p>想象除了这些计算机外，出现了一个偷窥者，这个偷窥者用某种我们不知道的方法，可以看见并且修改这个通道内的内容。那么这些正在获取 <code>index.html</code> 文件的计算机们是没有办法能够验证这些内容是不是被修改过的。他们能做的只是想尽办法加密这个通道。而这就是为什么我们现在有了 HTPPS。</p><p>而命名数据网络则解决了这些问题。在 NDN 网络中，我们不再需要关心地址，管道等一堆破烂事。我们只需要关心我们最想要关心的一样东西：数据。而我们获取数据的方式则是通过这个数据的「名字」，这也是「命名数据网络」这个名字的来源。在大部分情况下，这个「名字」会是数据的哈希值。哈希值是数据唯一的名字，只要这个数据发生了任何的变化，它的哈希值都会发生改变。所以我们可以利用这个特性来验证我们获取到的数据有没有被篡改过，这样就消除了偷窥者修改数据的可能性。</p><p><img src="image-20210119184605146.png" alt="命名数据网络的架构"></p><p>而当你不用再关心你要的数据存放在哪里的时，你就会发现，只要是数据是你要的数据，哪怕这个数据不是从最初的发布者那里来的也没关系。比如在上图中，计算机 A 如果想要文件 <code>index.html</code> ， 而计算机 C 之前从最初的发布者 D 那里获取过同样的文件，计算机 A 其实可以直接从 C 那里拿文件，而并不一定要从 D 那里拿文件。当然其实在大部分时候 C 其实是路由器，如果对具体的原理感兴趣可以看张丽霞教授的一个<a href="https://youtu.be/uoT7I4QlNEg">演讲</a>。</p><p>除此之外，命名数据网络还有很多其他的好处，但是因为篇幅所限，更多详细的细节比如：命名数据网络在物联网中的优势，具体数据包的种类，路由是如何传播的等，都可以去看我上面提到的张丽霞教授的演讲。</p><p>命名数据网络在提出之后，启发了一个全新的计算机网络的领域，这个领域被称作 Information-centric networking（信息中心网络），而这个领域的研究成果很可能在未来重塑我们的网络世界。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们的故事要回到 1974 年，彼时计算机主要形式还是大型机，创造计算机行业历史的 Apple I 要在两年后才正式面世，而我们熟知的万维网（World Wide Web）在整整十五年后才会被伯纳斯-李爵士在他的《关于信息化管理的建议》中提出。在那时我们现在使用的互联网还未</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>一个去中心化的网络论坛设计</title>
    <link href="http://blog.otakusaikou.com/2021/01/03/a-decentralized-internet-forum-desgin/"/>
    <id>http://blog.otakusaikou.com/2021/01/03/a-decentralized-internet-forum-desgin/</id>
    <published>2021-01-03T21:50:25.000Z</published>
    <updated>2021-03-25T03:58:48.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文讲介绍了一个基于 IPFS 去中心化论坛的设计，虽然用的 IPFS 技术，但是实际上这个设计也可以用于别的技术栈。同时这是个非常简单的设计，中间有很多可以优化的空间，本设计只为了读者提供思路。</p><h2 id="技术背景介绍"><a href="#技术背景介绍" class="headerlink" title="技术背景介绍"></a>技术背景介绍</h2><p>为了后续内容的阅读体验，我将对本设计涉及到的技术—— IPFS，做一个简单的介绍，当然这个介绍不会深入 IPFS 网络的细节，只是对 IPFS 这个抽象层的介绍，另外为了读者的阅读考虑，我尽量少引用术语，如果读者对 IPFS 网络的细节感兴趣，可以自行阅读 IPFS 的<a href="https://docs.ipfs.io/">文档</a>。</p><p><a href="https://ipfs.io/">IPFS</a>（InterPlanetary File System）又名星际文件系统，在一般的介绍里可能会说它是个「硬盘共享协议」，但我觉得它其实更像是个文件分享协议，如果你了解 BT 协议的话，IPFS 网络和 BT 网络是非常相近的。</p><p>在你加入 IPFS 网络之后，你和 IPFS 其他的节点一起构成一个内容存储的网络。在这个网络中，你上传到所有文件（或者文件夹）都有一个独一无二的 ID，称为 CID （Content Identifier)，你不需要知道这个 CID 是如何生成的，你可以直接把这个 CID 直接理解为文件的 Hash 值（类似 BT 网络中的磁力链接），也正是因为如此当你修改文件内容时候 CID 也会随之改变。通过 CID IPFS 可以实现文件的去重，也就是它不会存储 CID 相同的文件。当你需要获取一个文件时候，如果这个网络中有人缓存了这个文件且在线，你可以直接通过这个 CID 获取到你想要文件。</p><p>但是这个不可变性也带来了问题，如果我们需要一个可变的内容该怎么办？举例来说，我们想要发布一个静态网站到 IPFS 网络上，我们不可能每次在更新网页之后都给用户提供一个新的 CID 地址，用户需要一个固定的地址来访问我们的网站。而解决这个问题的办法就是 <a href="https://docs.ipfs.io/concepts/ipns/">IPNS</a>（InterPlanetary Name System）。你不用在意这个 IPNS 是如何如何实现的，你只需要知道，我们可以通过一个固定 IPNS 地址来访问最新的内容就行，当然你之前的内容如果有人缓存的话也会停留在IPFS网络上，但是如果没人缓存或者缓存内容的人不在线，那么之前的内容就会丢失了。</p><p>下面就是一个例子，你可以看到我们把 CID 为<code>QmSwMfsNFmUxn5D2BcHU2NGkuKoAEAaowdJ6Qdn9w1j8ev</code> 绑定到了<code>k2k4r8mu68txggqrlfp3zylq5rvabpgdhjz3uop2813at3g7xn3rbc3a</code>这个 name 上，当然我们也可以更新这个 name 绑定的 CID 。</p><p>不过 IPNS 并不是唯一实现这个功能的协议，这里只是为了方便所以使用了这个协议，其他类似的协议还有有，比如说 <a href="https://docs.ipfs.io/concepts/dnslink/#publish-using-a-subdomain">DNSLink</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ipfs name resolve k2k4r8mu68txggqrlfp3zylq5rvabpgdhjz3uop2813at3g7xn3rbc3a</span><br><span class="line">&#x2F;ipfs&#x2F;QmSwMfsNFmUxn5D2BcHU2NGkuKoAEAaowdJ6Qdn9w1j8ev</span><br></pre></td></tr></table></figure><p>以上就是这个设计所需要用到的技术的简单介绍。</p><h2 id="具体设计"><a href="#具体设计" class="headerlink" title="具体设计"></a>具体设计</h2><p>首先说明，这个设计基于一个最理想的情况，也就是所有用户都一直在线且会保存自己的文件，现实世界不一定如此。另外这只是一个初步的设计，肯定会有很多不完善的地方。此外为了简单起见，我们将用户的「回复」也作为「帖子」处理。</p><p><img src="network.jpg" alt="network"></p><p>在这个网络中，有两类节点，请注意这里的每个节点都有 IPNS 地址：</p><ul><li>论坛节点</li><li>用户节点</li></ul><p>其中「论坛节点」是这个论坛系统运作的核心，而这个节点中最为重要的文件就是 <code>users.csv</code> ，其具体内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ipns1,users1_id</span><br><span class="line">ipns2,users2_id</span><br><span class="line">ipns3,users3_id</span><br></pre></td></tr></table></figure><p>在这个文件中，记录了一系列的 IPNS 地址，这里的每一个 IPNS 地址指向了一个用户的发帖文件夹，而 <code>user_id</code> 则是用户的标识符，这里可以充当标识符的内容有很多比如：用户名、用户的公钥等。而用户注册这个论坛的方式，也就是向这个文件中加入一条记录，具体的注册方式有很多不同的解决方案，比如论坛的维护者可以做一个简单的网页来让用户注册。</p><p>而「主题文件」是作为发帖分类用的，具体的使用方式见下文。</p><p>在「用户节点」，用户需要创建一个文件夹，并在在这个文件夹内存放自己帖子，你在这个文件夹中添加新的文件就相当于发帖。用户需要按照以下协议进行发帖。</p><p>用户发帖格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Preview_CID:[回复&#x2F;帖子&#x2F;主题的CID,] </span><br><span class="line">Date:Unix时间戳</span><br><span class="line">File_Type:plain</span><br><span class="line">Title:</span><br><span class="line">Lorem ipsum </span><br><span class="line">Content:</span><br><span class="line">Lorem ipsum dolor sit amet, consectetur adipiscing elit. </span><br><span class="line">Pellentesque vitae scelerisque purus. Curabitur sed lectus ut sapien sodales hendrerit.</span><br></pre></td></tr></table></figure><p>这个格式主要分为两个区域： <code>Meta</code> 区域和 <code>Content</code> 区域</p><ul><li><code>Meta</code> 区域主要记录的发帖的「元信息」比如是个「新帖子」还是「回复」，要回复谁或者要发到哪个分类下。</li></ul><p>在这个分类中有一个 <code>Preview_CID</code>，它接受一个 CID 组成的数组，这里的 CID 可以是某个帖子、回复或者论坛提供的主题的 CID。</p><ul><li><code>Content</code> 区域主要记录发帖的内容，比如帖子的标题和内容等。</li></ul><p>在这个分类中  <code>Title</code> 表示帖子的的标题，而 <code>Content</code> 表示帖子的具体内容。</p><p>用户在发布一个新的「帖子」之后，需要更新自己的 IPNS 地址的绑定来添加新的内容。</p><p>而用户获取他人帖子的具体步骤如下，首先去论坛节点的 IPNS 地址获取到最新的 <code>users.csv</code>，然后根据这个列表上的其他用户的 <code>IPNS</code> 地址获取到其他用户的最新发帖，最后根据用户发帖中的 <code>Preview_CID</code> 信息将讨论串拼接起来。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>首先我还是得重复一下，这个是个非常简单的设计，中间肯定会有非常多可以优化的地方。</p><p>在这个设计中，你发的所有帖子都是先存放在本地，当别人需要的时候才会被同步出去，这意味着你不用担心你的贴文内容会被「论坛」所控制，也不会因为某天论坛消失了，你得发的内容也消失了。此外因为 IPFS 网络的特性，你只要能连上 IPFS 网络，你就可以获取到 <code>users.csv</code> ，这样也解决了因为你所在的公司、地区和国家进行了网络封锁导致你无法访问的论坛的问题。</p><p>上面看上去都是这个这个分布式论坛看得到的好处，我觉得看不到的好处也很重要，因为它很有趣，这是个基本上没多少先例的领域，创造之前没有人做过的东西总是很有趣的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;本文讲介绍了一个基于 IPFS 去中心化论坛的设计，虽然用的 IPFS 技术，但是实际上这个设计也可以用于别的技术栈。同时这是个非常简单的设</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>软件工程师装屄指南</title>
    <link href="http://blog.otakusaikou.com/2020/11/19/how-to-become-a-poser/"/>
    <id>http://blog.otakusaikou.com/2020/11/19/how-to-become-a-poser/</id>
    <published>2020-11-19T10:25:38.000Z</published>
    <updated>2021-03-25T03:58:48.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="免责说明"><a href="#免责说明" class="headerlink" title="免责说明"></a>免责说明</h2><p>首先说明，本文是戏文，并没有实际映射到到某个人，如果你发现有些人能对号入座，那我倍感荣幸。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在现在的互联网上，你总是能在各种的广告、书籍的腰封和社交媒体上看到各式各样的人在称呼各种各样的人为「大神/大佬/牛人」。我对这些称呼并无好感，而且这也不是本文的重点，本文的重点是：如何让你成为一个这样的人。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在要开始成为这些人之前，你得先做点准备工作，确切的来说你得准备一下你的背景。为了让人在第一印象中觉得你很牛屄，一个精心准备的背景是必不可少的。那么接下来的问题就是，怎么样才算得上是个「精心准备的背景」呢？答案很简单，就和你写工作简历一样，突出你之前相对来说做的好的地方。当然在互联网上宣传自己，还是和写简历有所区别。</p><ol><li>学习经历，如果你有海外名校或者国内名校的学习经历，可以写上，如果没有就不用写了</li><li>工作经历，这里和写简历不同，你不需要突出你具体干了哪些事，可以直接写公司名称，借着公司招牌宣传自己</li><li>项目经历，有最好，如果没有一个非常牛屄项目经历就不用写了，当然如果你是某个著名开源项目的贡献者，你可以写上。</li></ol><p>总儿言之这里的关键点是「借者别人的名号宣传自己」。换句话说，你要想尽办法拉起别人的大旗，哪怕这个旗和你只有一点点沾边。</p><h2 id="培养名声"><a href="#培养名声" class="headerlink" title="培养名声"></a>培养名声</h2><p>有了背景之后，接下来就需要培养名声了。其实这里应该还有做角色定位的一步，但是我觉得一个人不能做不符合自己内心的事太久，所以按照你的喜好来就行。</p><p>那么接下的问题就是如何培养名声。首先要选择你的话题，选择话题的第一要点是要选你喜欢的立场，其次是要选择大家都关心的事，另外这里你还得选择和大部分看法相反的立场或者相近的立场，中间派是没法快速收获名声的，具体怎么选就看你怎么想了。</p><p>在互联网上，收集名声最好的方法还是写文章，当然我知道对于大部分的软件工程师来说，写文章还是过于的困难了。所以这里有个简便的方法，也就是所谓的「洗稿」。当然，如果你洗中文世界的稿，先不说别人会不会来找你，光是中文世界文章这个落后性，你就赚取不了名声。所以，你可以洗英文世界的稿件。你需要做的就是到类似 Hacker News 的网站上，找一些话题相同的文章，半翻译，半插入几句自己观点的方式，将其变成一篇中文的稿件。</p><p>有了稿件之后，下一步就是如何发布这些稿件，非常简单，去各种社交媒体上发布就行，什么知乎，微信公众号，当然作为软件工程师你的博客上也需要有一份。什么，你说你是在文章里反对微信的，不想到微信公众号里发文章。别闹了，流量才是关键，大家看的是个情绪，谁管你是真做还是假做。哪怕有人指责你，你也可以写点不痛不痒的话圆回来。</p><p>当然另一个好的办法就是通过类似微博或者推特的平台收集名声。你只需要稍微转发几条英文的新闻，别忘了加上一些看上去有道理的评论，粉丝名气自然而然的就来了。不过这种转发效应太慢，还是写文章来的快。</p><h2 id="公关"><a href="#公关" class="headerlink" title="公关"></a>公关</h2><p>随着时间的积累，你肯定会收获一点名气，于此同时也肯定会有一些人来批评你。对于这些人解决方法有两种：如果他比起你来没什么名气，你直接拉黑，屏蔽一条龙就行。如果批评你的人比起你的名气要大很多，那么就是坚决斗到底，这样你你还可以吸引一批不喜欢对方的人。</p><p>另外，在收获名声的过程中，你还得学会抱大腿，加入各种名人的圈子，这样别人有意无意的带上你，你也可以收获大批粉丝。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;免责说明&quot;&gt;&lt;a href=&quot;#免责说明&quot; class=&quot;headerlink&quot; title=&quot;免责说明&quot;&gt;&lt;/a&gt;免责说明&lt;/h2&gt;&lt;p&gt;首先说明，本文是戏文，并没有实际映射到到某个人，如果你发现有些人能对号入座，那我倍感荣幸。&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>X86 软路由配置 IPv6 踩坑小记</title>
    <link href="http://blog.otakusaikou.com/2020/11/11/x86-soft-router-and-ipv6/"/>
    <id>http://blog.otakusaikou.com/2020/11/11/x86-soft-router-and-ipv6/</id>
    <published>2020-11-11T12:46:28.000Z</published>
    <updated>2021-03-25T03:58:48.771Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景故事"><a href="#背景故事" class="headerlink" title="背景故事"></a>背景故事</h2><p>这一次踩坑之旅的起源是一段来自内核恐慌 Telegram 群的关于 IPv6 的讨论，<a href="https://twitter.com/RioJot">Rio</a> 发了关于他配置 IPv6 时候的踩坑<a href="https://www.v2ex.com/t/722411">帖子</a>，而我正好一直想把家里软路由的 IPv6 配置起来，就有了这一次经历。这里非常感谢 Rio 和听众群的朋友，没有他们的帮助也就没有这次的经历。</p><h2 id="关于-IPv6-的小介绍"><a href="#关于-IPv6-的小介绍" class="headerlink" title="关于 IPv6 的小介绍"></a>关于 IPv6 的小介绍</h2><p>在开始配置环境之前，我想先做一个关于 IPv6 的小介绍。介绍一下之后会涉及到的一些概念，比如：RA，slaac 等。这个介绍不会涉及到 IPv6 整体是怎么工作的，主要介绍一下在 IPv6 设备是如何获取 IPv6 地址的。</p><p>在开始介绍在 IPv6 环境之前，得先介绍一下什么是 RA。RA 也就是：Router Advertisement（路由器通告报文）是一种 ICMPv6 报文，ICMP 也就是我们日常 Ping 命令使用的报文。在 IPv6 点环境中路由发出的 RA 会携带一系列的信息告知设备如何配置自己的 IP 地址。</p><p>在 IPv6 中有多种自动配置 IP 的方式，这里我们只会接触到 slaac 和 DHCPv6，下面有个关于这两种方式区别的解释。</p><blockquote><p><strong>其中“自动配置”根据获取方式，又分为</strong></p><p>▷ 无状态（Stateless）：根据路由通告报文RA（Router Advertisement）包含的prefix前缀信息自动配置IPv6地址，组成方式是Prefix + (EUI64 or 随机)。Stateless也可以称为SLAAC（Stateless address autoconfiguration）</p><p>▷ 有状态（Stateful）：通过DHCPv6方式获得IPv6地址</p><p>——<a href="https://cloud.tencent.com/developer/article/1517325">IPv6系列-详解自动分配IPv6地址</a></p></blockquote><p>因为安卓设备只支持 slaac，所以我使用了 slaac 方式配置局域网内设备的IP。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>我这里使用系统是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux version 4.19.0-9-amd64 (debian-kernel@lists.debian.org) (gcc version 8.3.0 (Debian 8.3.0-6)) #1 SMP Debian 4.19.118-2+deb10u1 (2020-06-07)</span><br></pre></td></tr></table></figure><p>机器本身是一台四个网口的软路由。</p><p>上网方式是 PPPoE 拨号上网</p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>首先配置网卡。</p><p><code>/etc/network/interfaces</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;network&#x2F;interfaces.d&#x2F;*</span><br><span class="line"></span><br><span class="line"># 本地接口</span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line"># 广域网接口</span><br><span class="line">allow-hotplug enp1s0</span><br><span class="line"></span><br><span class="line"># 局域网接口</span><br><span class="line">auto br0</span><br><span class="line">allow-hotplug br0</span><br><span class="line">iface br0 inet static</span><br><span class="line">      address 192.168.2.1</span><br><span class="line">      network 192.168.2.0</span><br><span class="line">      netmask 255.255.255.0</span><br><span class="line">      brocast 192.168.2.255</span><br><span class="line">      bridge-ports enp2s0 enp3s0 enp4s0</span><br><span class="line">      </span><br><span class="line"># PPPoE 接口，由 pppoeconf 自动生成</span><br><span class="line">auto dsl-provider</span><br><span class="line">iface dsl-provider inet ppp</span><br><span class="line">pre-up &#x2F;bin&#x2F;ip link set enp1s0 up # line maintained by pppoeconf</span><br><span class="line">provider dsl-provider</span><br><span class="line">iface enp1s0 inet manual</span><br></pre></td></tr></table></figure><p>这里是我的的软路由的接口配置，可以看到出口网卡是 enp1s0，我会通过这个网卡进行 PPPoE 拨号上网。这个配置最后的 <code>dsl-provider</code> 是由 pppoeconf 自动生成的，我们之后会讲到。</p><p>请注意，在这里不要配置 DHCP 连接，不然内置的  dhclient 会和之后我们用到的 <code>wide-dhcpv6-client</code> 冲突。</p><p>因为我们是要配置软路由，所以我们需要启用 IPv6 转发。</p><p>在  <code>/etc/sysctl.conf</code> 添加上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">net.ipv6.conf.all.forwarding&#x3D;2</span><br><span class="line">net.ipv6.conf.default.forwarding&#x3D;2</span><br><span class="line"></span><br><span class="line">net.ipv6.conf.all.accept_ra&#x3D;2</span><br><span class="line">net.ipv6.conf.default.accept_ra&#x3D;2</span><br><span class="line"></span><br><span class="line">net.ipv6.conf.all.use_tempaddr&#x3D;2</span><br><span class="line">net.ipv6.conf.default.use_tempaddr&#x3D;2</span><br></pre></td></tr></table></figure><p>我们通过设置: <code>net.ipv6.conf.all.forwarding=2</code> 和 <code>net.ipv6.conf.default.forwarding=2</code> 启用了 IPv6 转发，但是根据注释：</p><blockquote><p>Uncomment the next line to enable packet forwarding for IPv6</p><p>Enabling this option disables Stateless Address Autoconfiguration</p><p>based on Router Advertisements for this host</p></blockquote><p>开启了这个选项之后，系统将不会进行 RA 处理，也就是我们的广域网将不会有 IPv6 地址，所以我们这里手动设置了：<code>net.ipv6.conf.all.accept_ra=2</code> 和 <code>net.ipv6.conf.default.accept_ra=2</code> 来启用 RA 处理。</p><p>最后两行是启用 IPv6 的隐私扩展，具体可以阅读 Arch Wiki 的相关<a href="https://wiki.archlinux.org/index.php/IPv6_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">介绍</a>。</p><p>因为 RA 是 ICMPv6 报文，所以我们要在防火墙上允许 ICMPv6 的通过。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p ipv6-icmp -j ACCEPT</span><br><span class="line">iptables -A FORWARD -p ipv6-icmp -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -p ipv6-icmp -j ACCEPT</span><br><span class="line">ip6tables -A INPUT -p ipv6-icmp -j ACCEPT</span><br><span class="line">ip6tables -A FORWARD -p ipv6-icmp -j ACCEPT</span><br><span class="line">ip6tables -A OUTPUT -p ipv6-icmp -j ACCEPT</span><br></pre></td></tr></table></figure><p>接下来我们来配置 PPPoE 上网，运行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install pppoeconf</span><br></pre></td></tr></table></figure><p>在安装 <code>pppoeconf</code> 的时候会自动安装 <code>pppd</code>，<code>pppoeconf</code> 是个帮助你配置 <code>pppd</code> 的小工具，安装完成后输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pppoeconf</span><br></pre></td></tr></table></figure><p>然后按照指示输入你宽带的账号密码，如果其他选项的含义不清楚请选择默认，在配置成功后，你可以通过: <code>poff</code>，<code>pon</code> 和 <code> plog</code>，来关闭、开启 PPoE 以及显示 log。</p><p>但是在默认的情况下，<code>pppoeconf</code> 自动生成的配置文件不会启用 IPv6，我们还需要对配置文件进行一些修改。</p><p>配置文件在 <code>/etc/ppp/peers/</code> 目录下，我这里自动生成的是 <code>dsl-provider</code>。</p><p><code>/etc/ppp/peers/dsl-provider</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">noipdefault</span><br><span class="line">defaultroute</span><br><span class="line">replacedefaultroute</span><br><span class="line">hide-password</span><br><span class="line">noauth</span><br><span class="line">persist</span><br><span class="line">persist</span><br><span class="line">maxfail 0</span><br><span class="line">plugin rp-pppoe.so</span><br><span class="line">nic-enp1s0</span><br><span class="line">user &quot;宽带账号&quot;</span><br><span class="line">usepeerdns</span><br><span class="line">+ipv6</span><br><span class="line">debug</span><br></pre></td></tr></table></figure><p>这里我在末尾添加上了<code>+ipv6</code>，请注意加号，其次我还添加上了 <code>debug</code>，用于之后使用 <code>plog</code> 来 Debug 问题，此时你重新启动 PPPoE，然后输入 <code>ip addr show ppp0</code>，观察 <code>ppp0</code> 接口应该就能看到分配的 IPv6 地址了，因为我们启用了隐私扩展，所以你能看到有两个 IPv6 地址。</p><p><img src="ppp0.jpeg" alt="ppp0"></p><p>接下来我们需要给内网设备也分配对应的 IPv6 地址。这里我们用到了 Prefix delegation（<a href="https://zh.wikipedia.org/wiki/%E5%89%8D%E7%BC%80%E4%BB%A3%E7%90%86">前缀代理</a>），简称 PD。简单来说就是我们向我们的上级路由发送 PD 请求，上级路由会分给我们一个前缀长度小于等于64的网段，然后我们就能将个网段划分成一个或者一些 /64 的网段接着向局域网内的设备分配，此时局域网内的设备的上级路由就是我们的网关。</p><p>这里有个需要注意的地方，我们向局域网设备分配的 IP 地址也是公网地址，而不是 IPv4 时代的私有地址，不过因为上级路由是我们的网关，所以这些设备其实是在一个局域网内，并且因为这些地址都是公网地址，所以我们不需要做 NAT 转化的操作。</p><p>为了实现这个功能，我们需要使用 <code>wide-dhcpv6-client</code>。</p><p>首先安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install wide-dhcpv6-client</span><br></pre></td></tr></table></figure><p>在安装完成后，我们需要配置 PD。</p><p>编辑：<code>/etc/wide-dhcpv6/dhcp6c.conf</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface ppp0 &#123;</span><br><span class="line">  send ia-pd 0;</span><br><span class="line">&#125;;</span><br><span class="line">id-assoc pd 0 &#123;</span><br><span class="line">  # use the interface connected to your LAN</span><br><span class="line">  prefix-interface br0 &#123;</span><br><span class="line">    sla-id 1;</span><br><span class="line">    sla-len 4;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这段配置也是来自 <a href="https://wiki.archlinux.org/index.php/IPv6_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Archi Wiki</a>，其中的 <code>ppp0</code> 应该是你广域网的接口，而 <code>br0</code> 应该是你局域网的接口，关于 <code>sla-len</code>的长度有个注释需要注意：</p><blockquote><p><strong>注意：</strong> <code>sla-len</code> 应设置为满足 <code>(WAN-prefix) + (sla-len) = 64</code> 的值。这里示范的情况是针对一个长度 <code>/56</code> 的前缀，56+8=64。对于前缀长度 <code>/64</code> 的网络，<code>sla-len</code> 应为 <code>0</code>。</p></blockquote><p>因为我的 ISP 分配的是个 <code>/60</code> 的网段，所以 <code>sla-len</code> 的值是 <code>4</code>，我建议大家可以先填成 <code>0</code>，然后通过运行：<code>dhcp6c -f -D ppp0</code> 命令，观察你的 ISP 分配的网段大小，然后再修改对应的值。</p><p>这里非常感谢 Rio 提供的一个新的现代化的 DHCP6c System Service 用来替换自带的 <code>wide-dhcpv6-client.service</code> 。</p><p>添加到 <code>/etc/systemd/system/dhcp6c.service</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;WIDE DHCPv6 Client</span><br><span class="line">Wants&#x3D;network-online.target</span><br><span class="line">After&#x3D;network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;sbin&#x2F;dhcp6c -f ppp0</span><br><span class="line">ExecReload&#x3D;&#x2F;bin&#x2F;kill -HUP $MAINPID</span><br><span class="line">Restart&#x3D;on-failure</span><br><span class="line">RestartSec&#x3D;3</span><br><span class="line">NoNewPrivileges&#x3D;yes</span><br><span class="line">PrivateTmp&#x3D;yes</span><br><span class="line">ProtectHome&#x3D;yes</span><br><span class="line">ProtectSystem&#x3D;strict</span><br><span class="line">ReadWritePaths&#x3D;&#x2F;run&#x2F; &#x2F;var&#x2F;log&#x2F;</span><br><span class="line">ProtectKernelTunables&#x3D;yes</span><br><span class="line">ProtectControlGroups&#x3D;yes</span><br><span class="line">SystemCallFilter&#x3D;~@mount</span><br><span class="line">SystemCallArchitectures&#x3D;native</span><br><span class="line">LockPersonality&#x3D;yes</span><br><span class="line">MemoryDenyWriteExecute&#x3D;yes</span><br><span class="line">RestrictRealtime&#x3D;yes</span><br><span class="line">RemoveIPC&#x3D;yes</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure><p>然后运行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop wide-dhcpv6-client.service</span><br><span class="line">systemctl disable wide-dhcpv6-client.service</span><br><span class="line">systemctl enable dhcp6c.service</span><br></pre></td></tr></table></figure><p>你就可以通过 <code>dhcp6c.service</code> 来控制 <code>wide-dhcpv6-client</code> 了。</p><p>运行成功后，观察你局域网的接口，应该就能看到对应分配的地址了。</p><p><img src="lan.jpeg" alt="lan"></p><p>最后需要向局域网设备发送 RA ，使用 slaac 来分配IP地址，这里我们使用了 Dnsmasq，因为 Dnsmasq 是个非常常用的软件，就不多介绍了，在 Dnsmasq 的配置文件里加上:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enable-ra</span><br><span class="line">dhcp-range&#x3D;::,constructor:br0,ra-only,slaac</span><br></pre></td></tr></table></figure><p><code>br0</code> 填入你的局域网接口。</p><p>这时你的局域网设备应该也能分配到全球唯一的 IPv6 地址了。</p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>DHCPv6C 在我这里的环境里会会出现一个不知为什么的 Bug，体现就是 IPV6 的在成功运行一段时间后断开。我切换到了系统自带的 DHCPCD 上，具体的配置方法可以参见 <a href="https://wiki.archlinux.org/index.php/IPv6#With_dhcpcd">Archi Wiki</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景故事&quot;&gt;&lt;a href=&quot;#背景故事&quot; class=&quot;headerlink&quot; title=&quot;背景故事&quot;&gt;&lt;/a&gt;背景故事&lt;/h2&gt;&lt;p&gt;这一次踩坑之旅的起源是一段来自内核恐慌 Telegram 群的关于 IPv6 的讨论，&lt;a href=&quot;https://tw</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>世界与我们</title>
    <link href="http://blog.otakusaikou.com/2020/11/08/the-world-and-us/"/>
    <id>http://blog.otakusaikou.com/2020/11/08/the-world-and-us/</id>
    <published>2020-11-08T00:58:36.000Z</published>
    <updated>2021-03-25T03:58:48.735Z</updated>
    
    <content type="html"><![CDATA[<p><img src="nytime.jpg" alt="image-20201105123703489"></p><p><img src="the-economist.jpg" alt="image-20201105123703489"></p><p><img src="new-yorker.jpg" alt="image-20201105123703489"></p><p><img src="wjl.jpg" alt="image-20201105123703489"></p><p><img src="time.jpg" alt="image-20201105123703489"></p><p><img src="bbc.jpg" alt="image-20201105123703489"></p><p><img src="reuters.jpg" alt="image-20201105123703489"></p><p><img src="xinhuanet.jpg" alt="image-20201105123703489"></p><p><img src="caixin.jpg" alt="image-20201105123703489"></p><p><img src="huanqiu.jpg" alt="image-20201105123703489"></p><p><img src="people-net.jpg" alt="image-20201105123703489"></p><p><img src="peoples-daily-twitter.jpg" alt="image-20201105123703489"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;nytime.jpg&quot; alt=&quot;image-20201105123703489&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;the-economist.jpg&quot; alt=&quot;image-20201105123703489&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>如何写一个教程</title>
    <link href="http://blog.otakusaikou.com/2020/11/05/how-to-write-a-tutorial/"/>
    <id>http://blog.otakusaikou.com/2020/11/05/how-to-write-a-tutorial/</id>
    <published>2020-11-05T12:19:08.000Z</published>
    <updated>2021-03-25T03:58:48.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着社区人数的增加，各种相关教程的数量也开始增长，但是就我的观察而言，很多教程并没有做到基本的可读性与可访问性。而这篇文章的目的就是介绍如何做出基本美观的教程。当然在这篇文章我不会提及如何创作教程内容，这篇文章的主要关注点是，教程创作的流程、部署以及发布。</p><h2 id="可读性和可访问性"><a href="#可读性和可访问性" class="headerlink" title="可读性和可访问性"></a>可读性和可访问性</h2><p>首先要回答到是，什么是可读性和可访问性。我们先从可读性开始说明，可读性包括很多的方面：字体排版、网页的配色等。要一一说明显然是不现实的，这里我们就用一个例子说明。</p><p><img src="image-20201105123703489.png" alt="image-20201105123703489"></p><p><img src="image-20201105123738827.png" alt="image-20201105123738827"></p><p>这是同一段文本经过不同的排版方式后呈现出来的效果，我相信经过这个对比，应该很容易体会出为什么是什么可读性，以及为什么可读性是重要的。</p><p>接下来，是可访问性，你应该优先把教程作为一个的网页进行发布，而不是通过例如：加密的百度网盘分享一个 docx，来分发你的教程。</p><p>我们就以「加密的百度网盘分享一个 的 docx」作为例子，来说一下为什么这个是一种不好的方法。</p><p>首先加密的百度网盘就意味的一件事，这个教程是难以传播的，先不论如果通过百度网盘访问你的教程，还需要下载文件（并且忍受缓慢的速度），光是访问需要输入密码这件事，其实就是在减少你的教程的访问数量。</p><p>其次我们来讲一下分发 docx 文件为什么不好，你得先明确一点，docx 是 Microsoft Office 的格式而 Minecraft 是个跨平台的游戏，你的读者不是一定只是 Windows 用户，也可以是 macOS 和 Linux 用户，哪怕是 Windows 用户，也不一定就买了 Office，这一点就决定了对于他们来说打开 docx 其实并不是一件非常方便的事情。另外用 docx 来分发你的教程，如果你的教程需要持续更新，读者也需要不时的重新下载一遍，这个显然是不可取的。</p><p>有的作者可能会选择将自己的教程内容直接发布在某个论坛之上。但是这其实也不是一个非常好的办法，因为不同的论坛有不同的规定，你的教程很有可能在某天就变得无法访问了，这相当于将你的教程拱手送给了论坛。</p><p>而一个单独的网页则没有以上的问题，读者只需要输入地址即可访问，也不需要不断的重复下载一个文件，而且你可以自己控制网页的样式，并且可以做到自动化：在每次更新之后只要经过简单的步骤就可以更新对应的网页。</p><h2 id="撰写"><a href="#撰写" class="headerlink" title="撰写"></a>撰写</h2><p>你可以使用 <a href="https://zh.wikipedia.org/wiki/Markdown">Markdown</a> 作为你的写作格式，一切根据你需要来，有些作者可能会更加习惯 LaTex 等格式。关于 Markdown 的语法，这里就不多加说明了，非常容易学习。之后你得选定一个网页生成器，对于长篇的教程来说，合适的工具是各种电子书生成器，比如 <a href="https://github.com/rust-lang/mdBook">mdbook</a>（可能有的作者会使用 GitBook，但是 Gitbook 这个项目已经停止更新了，请不要使用了）。</p><p>接下来你就可以通过这些工具，写出一个精美的教程了。</p><h2 id="构建与发布"><a href="#构建与发布" class="headerlink" title="构建与发布"></a>构建与发布</h2><p>在你写了一定内容的教程之后，你接下来面临的一个问题就是如何发布你的教程，这里推荐使用 <a href="https://pages.github.com/">Github Pages</a> 的功能，你不需要有自己的域名和服务器，可以直接发布静态网页。当然，很多作者可能会将教程在本地构建完成，然后再通过 Git 同步到 Github 仓库上，但这其实不是一种好的方式，构建工作应该自动进行。你可以通过类似 <a href="https://github.com/features/actions">Github Action</a> 这样的工具，自动的构建与发布你的教程，这里是 Neutrino 的<a href="https://github.com/FledgeXu/Neutrino/blob/master/.github/workflows/deploy.yaml">例子</a>。</p><p>最后呈现出来的效果是，我只要修改好内容，然后向 Github push 修改好的内容，对应的网站会自动的更新与发布。</p><h2 id="一些额外事项"><a href="#一些额外事项" class="headerlink" title="一些额外事项"></a>一些额外事项</h2><p>在开始写作一个教程的时候，你需要选择一个合适的许可证，这个许可证会在一定程度上保护你的权利，这里建议使用 <a href="https://creativecommons.org/">Creative Commons</a> 系列许可证。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;随着社区人数的增加，各种相关教程的数量也开始增长，但是就我的观察而言，很多教程并没有做到基本的可读性与可访问性。而这篇文章的目的就是介绍如何</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>专业分工是给昆虫准备的</title>
    <link href="http://blog.otakusaikou.com/2020/11/02/specialization-is-for-insects/"/>
    <id>http://blog.otakusaikou.com/2020/11/02/specialization-is-for-insects/</id>
    <published>2020-11-02T14:53:13.000Z</published>
    <updated>2021-03-25T03:58:48.735Z</updated>
    
    <content type="html"><![CDATA[<p>仔细想想，这个博客需要有一个类似于「发刊词」一样的东西。当然不需要什么非常正式的发刊词，而是某种可以表明某种「觉悟」的东西。想了想用了这么一个标题：「专业分工是给昆虫准备的」。这个这句话其实是来自科幻小说家 <a href="https://en.wikipedia.org/wiki/Robert_A._Heinlein">Robert Heinlein</a> 的名言：</p><blockquote><p>“A human being should be able to change a diaper, plan an invasion, butcher a hog, conn a ship, design a building, write a sonnet, balance accounts, build a wall, set a bone, comfort the dying, take orders, give orders, cooperate, act alone, solve equations, analyze a new problem, pitch manure, program a computer, cook a tasty meal, fight efficiently, die gallantly. Specialization is for insects.”</p></blockquote><p>我本人其实并没有读过 Heinlein 的小说，这段话也是从李如一先生的<a href="https://blog.yitianshijie.net/2016/12/19/a-revolutionary-catalog/">博客</a>上读到的。但这段话确实象征了某些东西，某些对我而言非常重要觉悟。这个觉悟大概是我们要追求「完整性」，追求成为一个完整的人。</p><p>而这个博客里的内容自然也会非常广泛，只要我感兴趣的事物，估计都会有所涉猎。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;仔细想想，这个博客需要有一个类似于「发刊词」一样的东西。当然不需要什么非常正式的发刊词，而是某种可以表明某种「觉悟」的东西。想了想用了这么一个标题：「专业分工是给昆虫准备的」。这个这句话其实是来自科幻小说家 &lt;a href=&quot;https://en.wikipedia.org</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>你好世界</title>
    <link href="http://blog.otakusaikou.com/2020/11/02/Hello-Wolrd/"/>
    <id>http://blog.otakusaikou.com/2020/11/02/Hello-Wolrd/</id>
    <published>2020-11-02T14:16:19.000Z</published>
    <updated>2021-03-25T03:58:48.731Z</updated>
    
    <content type="html"><![CDATA[<p>看起来 Hexo 必须要有一篇文章才会生成 <code>index.htm</code>，那么我就创建这一篇文章作为占位符吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;看起来 Hexo 必须要有一篇文章才会生成 &lt;code&gt;index.htm&lt;/code&gt;，那么我就创建这一篇文章作为占位符吧。&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
