<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>曳东搬西</title>
  
  
  <link href="http://blog.otakusaikou.com/atom.xml" rel="self"/>
  
  <link href="http://blog.otakusaikou.com/"/>
  <updated>2023-04-15T01:24:06.259Z</updated>
  <id>http://blog.otakusaikou.com/</id>
  
  <author>
    <name>Fledge Shiu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何习得一门语言</title>
    <link href="http://blog.otakusaikou.com/2023/04/14/how-to-acquire-a-language/"/>
    <id>http://blog.otakusaikou.com/2023/04/14/how-to-acquire-a-language/</id>
    <published>2023-04-14T21:21:39.000Z</published>
    <updated>2023-04-15T01:24:06.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习的幻觉"><a href="#学习的幻觉" class="headerlink" title="学习的幻觉"></a>学习的幻觉</h2><p>许多人尝试过学习过许多语言，对于大部分的中文母语者来说，这个尝试过学习的外语里肯定包含着英文。我们都在学校系统里学习过英文，但是实际上大部分人从学校毕业之后依旧无法使用英文。如果对此进行一个简单的计算，我们在教育系统里，花费了超过十年时间来学习一门语言，但是最后却没什么结果，这个无疑是个巨大的浪费。然而与此同时，世界上又有很多polyglot，他们可以使用多种语言，有些人甚至知晓20门语言。他们究竟做对了什么，而我们又做错了什么？</p><p>这篇文章是我最近关于语言学习研究的一个总结，你可以把它当作学习一门语言的outlets来看。回到我们的问题，我们究竟做错了什么，而那些多语者究竟做对了什么。关于这件事，其实没有一个确切的答案。在语言学中，把学习一门外语称作「二语习得」，而关于二语习得的原理语言学家也是众说纷纭，在 <a href="https://www.goodreads.com/book/show/61271603-how-languages-are-learned-5th-edition"><em>How Languages are Learned 5th Edition</em></a> 一书中作者列出了至少4种不同的解释方向，每种解释方向又有不同具体的理论。可见关于人类如何学会第二门语言这件事，我们至今还是没有发现一个统一的理论解释。</p><p>不过幸运的是，在实际上我们可以忽视掉大部分的理论解释，在具体的教学和实践过程中，我们需要关注的只有两种理论：Skill-building hypothesis 和 Comprehensible inputs hypothesis（简称CI）。前者是迄今为止大部分国家教育系统所践行的理论，后者由 Dr. Stephen Krashen 在上个世纪八十年代提出，影响了大量的教师和之后关于第二语言学习的研究。</p><p>前者的想法是语言由各项能力构成，比如语法、词汇、发音等能力，只有单独<strong>学习</strong>一项项的能力，我们最后才能使用这门语言。而后者恰恰相反，我们的目标是使用语言从而<strong>习得</strong>一门语言，这些能力的增长只是我们不断使用这门语言自然而然获得的结果。</p><p>而目前根据实践看来，Skill-building hypothesis并没有取得一个很好的结果，即使有人声称他们取得了很好的结果，仔细观察他们的案例，其实用 CI 会更好的解释。</p><p>我们从来不能<strong>学习</strong>一门语言，我们只能<strong>习得</strong>一门语言，学习只是种幻觉。</p><h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><p>那么接下来的问题是我们到底要如何习得一门语言呢？答案也很简单，就是去阅读和聆听那些你大致上可以听的懂，可以理解的内容（不用100%理解，100%理解就没进步了），并且不断做下去，而这个就是comprehensible inputs这个名字的来源。这里我要引用 Dr. Stephen Krashen 说过的一句话：</p><blockquote><p>We acquire language in one way and only one way:  when we understand message</p></blockquote><p>当然这个理论实际上有很多具体的内容，这里我不想也懒得详细展开，如果感兴趣，可以看看 Dr. Stephen Krashen 自己做的一个<a href="https://www.youtube.com/watch?v=NiTsduRreug">演讲</a>，或者看看B站Up<a href="https://space.bilibili.com/323794482/video">罗肖尼Shawney</a>做的影片。</p><p>这里我想提一嘴输出的事，很多人看到这个理论后会想，如果我只做听和读，那么我的写怎么办呢？我个人的看法是，我总体上认同一个叫做 Silent Period 理论，在你输入没有达到一个量级，过早的做说和写是没有意义的，甚至会有反方向的影响，可能会让你习惯一些错误，从而在之后很难改正。当你达到一个量级，你可以大致上听得懂母语者日常的闲聊之后，你自然而然就能参与进这个聊天，这个时候你的依旧会犯错误，但是因为这个时候你的听和读已经可以支持起你和母语者的聊天，你的错误会自然而然被修正。</p><h2 id="你喜欢的是什么"><a href="#你喜欢的是什么" class="headerlink" title="你喜欢的是什么"></a>你喜欢的是什么</h2><p>最后一个问题是如何找到合适的材料。答案是我也不知道，因为每个人都有每个人不同的偏好，而材料对于学习的吸引力会直接决定这个材料的可用程度。在这个意义上，所谓的推荐材料是没有任何意义的。你，作为一个学习者，必须得发现你自己喜欢的，觉得吸引你的材料，另外当然你还得差不多看得懂这个材料。你可以不用查单词，因为母语者也是这么做的，你要的是相信你的大脑，人类的大脑擅长做联想，擅长观察规律，这个是我们大脑的本能，就像你能从下面这张图里看到三角形一样，请信任你的大脑。</p><p><img src="/2023/04/14/how-to-acquire-a-language/kanizsa-triangle2293929-prints.webp" alt="kanizsa-triangle2293929-prints"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;学习的幻觉&quot;&gt;&lt;a href=&quot;#学习的幻觉&quot; class=&quot;headerlink&quot; title=&quot;学习的幻觉&quot;&gt;&lt;/a&gt;学习的幻觉&lt;/h2&gt;&lt;p&gt;许多人尝试过学习过许多语言，对于大部分的中文母语者来说，这个尝试过学习的外语里肯定包含着英文。我们都在学校系统里学习</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>AT Protocol 简易游玩攻略</title>
    <link href="http://blog.otakusaikou.com/2023/01/08/how-to-play-with-at-protocol/"/>
    <id>http://blog.otakusaikou.com/2023/01/08/how-to-play-with-at-protocol/</id>
    <published>2023-01-08T00:29:05.000Z</published>
    <updated>2023-04-15T01:24:06.259Z</updated>
    
    <content type="html"><![CDATA[<p>最近终于成功的玩了玩AT Protocol，接下来的内容是攻略。主要参照了 adenosine 项目中的<a href="https://gitlab.com/bnewbold/adenosine/-/blob/main/notes/atproto_quickstart.md">指南</a>，感谢这个项目的作者，以及 AT Protocol Matrix 群组里人们的帮助。这个攻略主要是会用 <a href="https://httpie.io/">httppie</a> 这个工具，当然你可以使用任何你熟悉顺手的 API 调试工具。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>AT Protocol的API设计很简单，所有的API都由一个<a href="https://atproto.com/guides/lexicon">Lexion</a>定义，目前所有的Lexicon你可以在项目的<a href="https://github.com/bluesky-social/atproto/tree/main/lexicons">Lexicons文件夹</a>下找到。具体的 Lexicon 长的像是这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;lexicon&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;com.atproto.sync.getRoot&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;defs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;query&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Gets the current root CID of a repo.&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;parameters&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;params&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;required&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;did&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;did&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;The DID of the repo.&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;output&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;encoding&quot;</span><span class="punctuation">:</span> <span class="string">&quot;application/json&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;schema&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;object&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;required&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;root&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;root&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在这个 Lexicon 中，<code>id</code> 是 <code>com.atproto.sync.getRoot</code>，这个和之后的API地址有关。在<code>main</code>中，你可以看到<code>type</code>是<code>query</code>，这代表这个API用的是Get方法，在<code>parameters</code>你可以看到需要的参数和参数的类型。<code>output</code>中规定了输出结果。</p><p>具体来说，我们使用httpie调试的时会是如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http get http://localhost:2583/xrpc/com.atproto.sync.getRoot did==did:plc:yag4nqhc3ox77yj2bfjnvmaq</span><br></pre></td></tr></table></figure><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>首先你当然需要Clone项目<a href="https://github.com/bluesky-social/atproto">本身</a>，然后需要安装Node环境，建议安装一个Node环境管理工具（比如NVM），AT Protocol 目前使用的是 Node 18 的这个 LTS 版本。</p><p>当你配置好环境当然就是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn install --frozen-lockfile</span><br><span class="line">yarn build</span><br></pre></td></tr></table></figure><p>来安装依赖。</p><p>安装完成后，进入到 <code>packages/dev-env</code> 这个子项目，输入 <code>yarn run start</code> 就可以开启测试环境了，命令输入完成后你可以通过 <code>status()</code> 来查看状态。</p><p><img src="/2023/01/08/how-to-play-with-at-protocol/image-20230107195358730.png" alt="image-20230107195358730"></p><p>在默认情况下 CLI 会自动建立一个 PDS， 你可以把PDS理解成AT Protocol中的服务端，当然你也可以通过<code>startPds(port?: number)</code> 来新建更多的 PDS，具体的命令可以看<a href="https://github.com/bluesky-social/atproto/tree/main/packages/dev-env">README</a>。但是请注意，不管你建立多少个 PDS，这些PDS的domain都是<code>test</code>。</p><h1 id="游玩AT-Protocol"><a href="#游玩AT-Protocol" class="headerlink" title="游玩AT Protocol"></a>游玩AT Protocol</h1><p>当环境配置好之后，你就可以尽情的游玩 API 了。</p><p>AT Protocol API 调用很简单，API 地址为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&#123;PDSHost&#125;/xrpc/$&#123;LexiconID&#125;</span><br><span class="line">Example:</span><br><span class="line">http://localhost:2583/xrpc/com.atproto.sync.getRoot</span><br></pre></td></tr></table></figure><p>大体上的流程为：<code>Create Account</code> -&gt; <code>Create Session</code> -&gt; <code>Create or Delete Record</code>。另外 AT Protocol 使用到 JWT ，所以在某些API上需要使用Bearer Token来验证。</p><p>和账号有关的LexiconID列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">com.atproto.account.create 创建账号，请注意这里参数中的 handle 指的是username.domain，因为在测试环境domain都是test,所以handle会类似于jekyll.test.</span><br><span class="line">com.atproto.session.create 登陆账号，获取Toekn</span><br><span class="line">app.bsky.feed.getAuthorFeed 获取用户的Feed</span><br><span class="line">app.bsky.actor.getProfile 获取用户的Profile</span><br><span class="line">app.bsky.actor.updateProfile 更新用户的Profile</span><br><span class="line">com.atproto.repo.createRecord 创建Record，如果你是想发送Post的话，那么Post的Collection是app.bsky.feed.post</span><br></pre></td></tr></table></figure><p>这些API的用法你都可以直接看Lexicon文件中的定义，如果依旧不会使用可以直接在代码仓库中搜索这些ID，观察测试文件是怎么使用的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近终于成功的玩了玩AT Protocol，接下来的内容是攻略。主要参照了 adenosine 项目中的&lt;a href=&quot;https://gitlab.com/bnewbold/adenosine/-/blob/main/notes/atproto_quickstart.m</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Bluesky 的 AT Protocol 随想</title>
    <link href="http://blog.otakusaikou.com/2023/01/06/first-review-of-bluesky-and-atprotocol/"/>
    <id>http://blog.otakusaikou.com/2023/01/06/first-review-of-bluesky-and-atprotocol/</id>
    <published>2023-01-06T21:42:57.000Z</published>
    <updated>2023-04-15T01:24:06.259Z</updated>
    
    <content type="html"><![CDATA[<p>今天和朋友聊起 Twitter 最近发生的事情，想起来 Bluesky，发现他们已经<a href="https://blueskyweb.xyz/blog/10-18-2022-the-at-protocol">公布</a>他们的协议 <a href="https://atproto.com/">AT Protocol（Authenticated Transfer Protocol）</a>了。于是去看了一下，下面是感想。</p><p>首先这个名字一下子就让我想起 A.T. Field，不知道只是巧合还是团队也是 EVA 的粉丝，这个是个有意设计出来的名字。这个协议和 Mastodon 用的 ActivityPub 一样是个Federated 的协议，团队在FAQ里解释了<a href="https://atproto.com/guides/faq#why-not-use-activitypub">为什么不用ActivityPub</a>，我觉得他们指出的确实是ActivityPub的痛点。特别是用户数据保存和迁移这件事，我在实际使用Mastodon的时候见过很多真实的案例，是切实的痛点。在AT Protocol下，用户数据确实可以做到任意的迁移保存，而且不会丢失社交关系（这点其实对于社交网络协议来说来说很重要，Mastodon 在迁移之后会丢失被关注者的数据，相当于重新做一个新号）。另外因为 Bluesky 的团队有之前 IPFS 团队的成员，用户数据（Data Repository）在 AT Protocol 里使用 IPLD 储存的，如果是这样的话，AT Protocol 应该对于 IPFS 有原生的支持，之后兼容其他在 IPFS 网络上的东西应该也不困难。</p><p>因为这个协议是个 Federated 的协议，在他们的语境下 Mastodon 的 Instance 叫做 Personal Data Servers（PDS），交换方式使用的是 XRPC，我们之后再来讲 XPRC。PDS 似乎会把用户数据存储在 IPFS 上，但是 PDS 和用户之间的通讯应该是普通的HTTPS，PDS 和 PDS 之前的同步，目前还不是很清楚，因为用户数据是个 Merkle Search Tree，估计同步方式是是通过 HTTPS 传输 Root 的 CID，然后判断要不要同步这个 CID 吧。</p><p>只是 XPRC 其实就是一个是个带有 Schema 的 JSON-LD，在他们的语境里这个Schema 叫做 Lexicon（从某种意义上来说，这个是用 JSON 把 XML 重新发明了一次，不过确实 XML 的语法太繁琐了）。作为对比 ActivityPub 应该直接用的是 JSON-LD，如果我没记错的话。</p><p>在 AT Protocol，开发团队提到了一个叫做 Small-World 和 Big-World 的区别，这个我稍微有点没看懂。似乎这个 Small-world 的意思就是 PDS 只负责简单的传输和同步用户数据，而一些总体性的功能（比如热门、热搜之类的）交给爬虫和 index 服务来完成，这个倒是一个非常实际的选择。</p><p>总体来说 AT Protocol 比起 ActivityPub 来说是个更加轻便的协议，它在功能上没有 ActivityPub 那么大而全，但是协议在设计中也预留了很多可以扩展的空间，在AT Protocol 里应该只需要通过添加 Lexicon 就能添加新的功能了。不过我看了一眼现在已有的 Lexicon 没有锁推的功能😂，不过有一个可以邀请加入 Group 的功能，还挺神奇的。</p><p>AT Protocol 比起 ActivityPub 也更加注重用户数据的保存和迁移。在 AT Protocol 里用户的数据应该很容易的被保存，也很应该很容易的迁移，AT Protocol 在设计的时候也考虑到了 PDS 突然消失后，用户数据丢失的风险，在这点上比 ActivityPub 想的更加周到。另外按照协议的样子，PDS 的服务端应该不会很复杂，Self-Host 可能也会更加容易。</p><p>当用户的数据存在在 IPFS 上，那么用户可以很容易的备份和转移他们的数据，Sir Tim Berners-Lee 的 Solid 的愿景，也成了事实。</p><p>当然我这个只是一个粗略的感想，具体还有很多技术上的细节没有提及。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天和朋友聊起 Twitter 最近发生的事情，想起来 Bluesky，发现他们已经&lt;a href=&quot;https://blueskyweb.xyz/blog/10-18-2022-the-at-protocol&quot;&gt;公布&lt;/a&gt;他们的协议 &lt;a href=&quot;https://a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>2022年疫病下的广州面签攻略</title>
    <link href="http://blog.otakusaikou.com/2022/05/04/usa-f1-visa-interview-under-2022-covid-in-guangzhou-consulate/"/>
    <id>http://blog.otakusaikou.com/2022/05/04/usa-f1-visa-interview-under-2022-covid-in-guangzhou-consulate/</id>
    <published>2022-05-04T17:43:19.000Z</published>
    <updated>2023-04-15T01:24:06.267Z</updated>
    
    <content type="html"><![CDATA[<p><strong>请注意，我这次经历发生在2022年4月低至5月初，春末夏初这段疫病感染人数激增的时段，当你要开始准备的时候，情势很可能已然不同。</strong></p><h2 id="领事馆选择"><a href="#领事馆选择" class="headerlink" title="领事馆选择"></a>领事馆选择</h2><p>目前中国大陆有以下几个大使馆和总领事馆</p><ul><li>美国驻华大使馆</li><li><del>美国驻上海总领事馆（暂时关闭）</del></li><li>美国驻沈阳总领事馆</li><li>美国驻广州总领事馆</li><li><del>美国驻武汉总领事馆（不提供签证服务）</del></li><li><del>美国驻成都总领事馆（已闭馆）</del></li></ul><p>在我打算去面签的时候，实际上只有三个领事馆可供选择，由于严格的进京政策和东北相对严重的封锁、更少的开放位和传说更高的拒绝签率，故此选择了广州总领事馆。</p><h2 id="交通工具的选择"><a href="#交通工具的选择" class="headerlink" title="交通工具的选择"></a>交通工具的选择</h2><p>从浙江出发前往广州有两种主要的交通方式：高铁和飞机。<br>线路大致上可以分为三种：</p><ol><li>直接坐飞机飞往广州</li><li>做高铁前往广州</li><li>做飞机飞往深圳然后再高铁转往广州</li></ol><p>因为深圳入广州的政策不确定性，所以我暂时排除了第3种。由于飞机超级高的取消率，所以我也买了高铁票备用。<br>关于买机票，可以参照「飞常准」和「航旅纵横」的「历史取消率」数据来确定航班，不过即使你买了看上去「比较稳」的航班，其实上也可能会被取消。而我正是被取消航班的那一类，当日杭州到广州的所有飞机票全部被取消。另外在我出发去广州的这段时间，广州白云机场附近有很多「高风险地区」，如果选择乘坐飞机直接去广州的话，需要考虑这点。</p><p>如果不想要做很久的高铁，可以考虑试试走飞到深圳的路线然后再去广州的路线。</p><p>因为航班被取消了，所以我只能选择乘坐早上6点多出发的高铁前往广州，总计8小时旅途时间。</p><h2 id="前往领事馆的经历"><a href="#前往领事馆的经历" class="headerlink" title="前往领事馆的经历"></a>前往领事馆的经历</h2><p>坐高铁的经历其实没什么特别好说的，请遵从你当地的「防疫要求」。主要说一下，到了广州南站之后的事的经历。从高铁站下来需要做一次集中的核酸检测，需要<strong>扫码填写个人信息</strong>。之后就可以正常出行了，之后基本上也没有什么严格检查。</p><p>建议到了预定的酒店之后，可以预先探一下到领事馆的签证处的线路。 </p><h2 id="实际面签"><a href="#实际面签" class="headerlink" title="实际面签"></a>实际面签</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>物品寄存方面我觉得没什么特别需要说的了，网上的各种指南很多，我是直接把我的包寄存在我住的酒店的前台（我住的酒店非常近）。</p><p>其实提前你面签时间的半个小时至四十五分钟到达面签地点就行，如果你去的比较早，保安会让你在排队带坐着等待（但是他会忘了叫你回来，你要自己时不时问一下排队情况，所以还是不要去的太早）。</p><p>在正式进入领事馆之前，会有一个检查预约表和给你的护照贴条形码的环节，这个条形码在之后的各个环节都会用到，贴完之后建议把你的预约表和护照放进你装材料的袋子，接下去需要过安检。</p><p>接下去就是进入领事馆的安检环节了，这部分需要把你身上所有的东西都放人资料袋，然后过安检，和国内安检不一样的地方可能只有需要脱皮带了，如果你穿的裤子是需要皮带的请注意一下。另外在通过安检之后，你的护照和面签预约表就不建议放起来了，因为之后一路都会用到。</p><p>过完安检，你会被领进签证楼，里面就是面签的地方了。进入签证楼之后你会看到一面巨大的美国国旗，签证楼内部右手边的一排窗口是用来进行各项签证事务的。</p><p>进入签证楼的时候，会有一个志愿者给你报号，你需要按照这个报号到指定的窗口，这个窗口的工作人员是中国人，他们会对你的护照和预约表之类的基础信息检查。</p><p>检查完之后，你会开始指纹信息录入的排队，从这个步骤起工作人员就是外国人了。在排队的时候会有一个荧幕不断播放指纹输入的方法，输入的签证官虽然中文不行，但是会给你比划如何输入指纹。我当天去的时候，开了两个录入指纹的窗口，另外教你录入指纹的人应该也是面签官，他们会互相换工作。</p><p>指纹录入结束之后就是排队等待面签了，根据之前面签的人给我提供的一个小技巧，如果你发现你要被分配到你不喜欢的面签官，可以借口上厕所，重新排队，但是重新排队时间很长，而且可能重新排完之后还是那个人，这个技巧慎用。</p><h3 id="VO"><a href="#VO" class="headerlink" title="VO"></a>VO</h3><p>我当天分到的是一个挺漂亮的似乎是亚裔混血的面签官，当天的通过率并不低，直接过签的挺多的，但是可能是敏感专业的缘故，我依旧被check了。我在排队时候认识的一个中年大叔，他申请探亲签证，在19年在上海领事馆被拒了两次，这次广州领事馆也给他了上交护照的check。我觉得如果你不是敏感专业，不用太过担心被拒。</p><p>在今天的VO里，有一个年纪比较大的白人男性签证官，他面签的时间很长，但是通过率给的通过还是挺多的。还有一个黑人女性的签证官，听我面签前一日面签的人说，通过率高，但是我没有实际的感觉。</p><h3 id="面签"><a href="#面签" class="headerlink" title="面签"></a>面签</h3><p>当轮到你之后，你会站在某个窗口前等待前面的人面签结束，这个时候你其实就可以做一些准备了，首先可以把I20、DS160、护照还有面签预约单都拿出来，这几样东西是签证官一定会看的，另外你可以准备好把口罩摘下，面签的时候需要脱下口罩。</p><p>上一个人结束之后，可以不用着急赶进去，签证官有时候需要处理一下上一个人遗留的一些内容，你可以等他们处理完，然后挥一下手再进去，签证官会默认用中文和你打招呼，因为我申请的是F1学签，所以直接回了”Morning”，所以之后面签官也都是和我说英文，接下来的面签过程也都是用英文进行。</p><p>签证官主要问了我一下的问题</p><ul><li><p>What’s your major?</p><p>我的回答是 Computer Science。</p><ul><li><p>接着她又细问我了一下有什么具体的方向吗？</p><p>我回答没有什么具体的方向</p></li></ul></li><li><p>Why do you choose 「I20上的学校」?</p><p>我就随便说了两句，然后强调了一下读这个学校可以便于我回国找工作（算是一点小心思吧，非移民签证还是需要强调一下你毕业想要立刻回国的）</p></li><li><p>Who sponsors you?</p><p>我回答我的父母，然后我也有收到学校的奖学金，然后我反问她”Do you need my scholarship letter?”</p><ul><li><p>在我反问的时候，她也正好想问我要”scholarship letter”</p><p>这部分我有点没做好，花了有点时候找scholarship letter，然后最后和录取通知书一起给她的，她似乎就看了一下录取通知书，也没有翻到scholarship letter的部分，所以在我的check单上，需要我补充scholarship letter。</p></li></ul></li><li><p>What’s your parents job?</p><p>正常回答。</p></li></ul><p>然后毫无例外的收到了护照给我发了绿色的check单，另外发check单之前都会稍微解释一下，需要将文件发到指定邮箱之类的事情。拿到check单之后我礼貌的说了句”Have a nice day”就走了，似乎好像没几个会结束之后说这句？我说这句话的时候她表情变化还蛮大的。</p><p>总体来说签证官们的人还挺好的，也都挺有耐性（我前面一个似乎也是申请F1签证，英文回答的磕磕绊绊，还时常听不懂，签证官也在挺耐性的重复问题的）。除了排队时间长，签证的体验倒是没什么不好的，结果也是预料之中的check，希望签证能早点issued吧。</p><p>另外一些小心思就是，在问Why或者Plan相关的问题的时候，可以强调一下你一定毕业马上回国，然后多主动反问签证官需不需要看某些资料，虽然他们不一定会看，可能敏感专业照样会check，但是面签体验可能会好些。然后我觉得可能比较重要的点就是，要尊重前面一位面签的人的隐私，不要太着急赶下一个，然后从面签开始到结束都要注意礼貌。</p><h2 id="Check-单要求"><a href="#Check-单要求" class="headerlink" title="Check 单要求"></a>Check 单要求</h2><p><img src="/2022/05/04/usa-f1-visa-interview-under-2022-covid-in-guangzhou-consulate/check.png" alt="check.png"></p><h2 id="值得注意的点"><a href="#值得注意的点" class="headerlink" title="值得注意的点"></a>值得注意的点</h2><ul><li>一定要住一个好一点的旅馆，广州的气候炎热，蚊虫很多，如果你没有找一个好一点的旅馆，很可能和我一样，一个晚上睡不了几个小时，全身全都是被蚊子叮的包，半夜起来狂打蚊子。</li><li>领事馆周围有好两家精酿啤酒吧，晚上很多外国人聚集，有一家还卖Tacco，但是我没去吃，稍微有点可惜。</li></ul><h2 id="回程"><a href="#回程" class="headerlink" title="回程"></a>回程</h2><p>回程我依旧选择乘坐了第二天的高铁，然后住了一个稍微好点的酒店，总算免除了蚊子的困扰。<br>我住在广州南站附近的维也纳酒店，酒店从早上六点起会有半小时一班的小客车把你从酒店送到南站，全程不需要几分钟，当然你想自己打车去走路去也行。<br>进入广州南站需要持有48小时内的核酸检测报告，因为我下广州南站的核酸检测还在这个时限内，所以不需要额外去做一次核酸检测报告。<br>在杭州东出站之后，杭州市不认广州的核酸检测的，在出站之后，工作人员会给你发一个「小红单」，上面会指引你去一个指定的地方免费做一次核酸检测，做完那个核酸检测，你可以领取一个小卡片（当然你的「健康码」上也会有一个标注提示你做了核酸检测，但是还没有结果），持有这些内容，你可以继续换站转乘。 </p><p>就这次在两地跑的时间点来说，我还是非常幸运的。在离开广州的高铁上，我发现广州在当日要开始全体48小时核酸检测了，而我回到家的晚上，我家附近出现了两个感染案例，而我的「健康码」也变黄了。不过幸好我已经到家了，不然就不知道会在哪里被中途隔离了，当然现在更无法乘坐高铁去外地了。</p><h2 id="关于Check的经历"><a href="#关于Check的经历" class="headerlink" title="关于Check的经历"></a>关于Check的经历</h2><p>目前看来如果是被真check的话，从Refused到Administrative Processing，大致上需要一个月左右，差不多4-5周。另外真Check应该是拿不到5年的Visa了，时间一般是1年，甚至也有少于一年的情况。小样本的情况显示，如果你是女性加上转专业，即使是CS也有水过签证的可能性，当然如果你持有港澳户籍，应该更不用担心被check。对于个人来说，同一个VO的更新进度可能更具参考价值一些，和同天面签，同一个VO，相同专业的另一位同学，也是和我同天AP，而另外两位不同VO的，要比我们两个还迟一些。</p><p>另外关于检测护照状态，可以使用moyu_ac这个公众号来帮助你自动检测进度（它应该是12小时检测一次，所以和具体的进度可能有时间上的差距，不过可以利用它在微信里快速查询状态，不需要去官网手工查询，还是挺方便的）。</p><h2 id="签证状态记录"><a href="#签证状态记录" class="headerlink" title="签证状态记录"></a>签证状态记录</h2><p>5.6 面签结束</p><p>5.6 13:00 check 材料上传完成</p><p>5.9 13:30 领事馆电话，提示需要补交 Offer 信（领事馆的绿单子没有提及这点，看当天的一起去签证人的反馈，这个不是特殊情况）。</p><p>5.9 16:35 收到回执信，正式进入等待时间。</p><p>6.10 16:25 结束Refused状态，进入Administrative Processing</p><p>6.13 10:30 issued，check结束，签证通过</p><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p>为了方便大家辨认VO，我弄了一张VO合影合集的AI增加版照片。<br><img src="/2022/05/04/usa-f1-visa-interview-under-2022-covid-in-guangzhou-consulate/all-vo.jpeg" alt="check.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;请注意，我这次经历发生在2022年4月低至5月初，春末夏初这段疫病感染人数激增的时段，当你要开始准备的时候，情势很可能已然不同。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;领事馆选择&quot;&gt;&lt;a href=&quot;#领事馆选择&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>DApp 是什么？</title>
    <link href="http://blog.otakusaikou.com/2021/04/11/what-is-the-dapp/"/>
    <id>http://blog.otakusaikou.com/2021/04/11/what-is-the-dapp/</id>
    <published>2021-04-11T11:21:21.000Z</published>
    <updated>2023-04-15T01:24:06.315Z</updated>
    
    <content type="html"><![CDATA[<p>DApp 也就是「Decentralized Application」的简称，按照很多营销号的说法是一个跨时代的技术。但是这东西其实远没有他们说的这么跨时代。这篇文章会从技术角度介绍一下什么是 DApp，以及它涉及到了哪些相关的技术，及其现阶段的问题有哪些，算是对我前段时间研究的一个小总结。另外本文不涉及到任何的投资建议，任何时候关于虚拟货币的投资都应该小心谨慎。本文是我前段时间研究的一个小总结。</p><p>DApp 其实指的不是一个单一的技术，它是一系列技术的综合体，整体架构可以用下图来表示。</p><p><img src="/2021/04/11/what-is-the-dapp/dapp_diagram.jpg"></p><p>在这张图中，展现了一个基于 IPFS 网络的 DApp 的架构。</p><p>可以看到其实整个 DApp 最为核心的部分是个前端的「单页应用（single page application）」。这个也是用户可以直接接触的部分。在 DApp 的架构中，页面会通过一个 IPFS 的网关呈现（当然其实不一定要 IPFS，其他的技术比如 Hypercore 也行，当然如果有 BT 的网关，也是可以的（笑），只是目前 IPFS 用的比较多而已）。这里 IPFS 网关的主要作用就是通过去中心化的方式来提供前端需要的资源（比如JS、CSS、HTML、图片等）。这部分通讯等方式和传统的网页没什么区别，就是普通的HTTP协议。</p><p>当然一般情况下，你是会希望你的 DApp 是可以和区块链进行操作的。比如查询余额之类的事情。这个时候你就需要一个接口，来进行链上操作，也就是上图提供的区块链网关。这个网关的作用和 IPFS 网关类似，只是这里提供的是区块链操作的相关接口。目前来看，真正实用的公链（其实差不多只有以太坊）的网关用的是 JSON-RPC 协议通讯，但这里要用什么样子的协议都行，看你用的区块链网关支持哪些协议。</p><p>最后一部分是和用户钱包的交互，一般会要求用户装一个钱包插件，这样你就可以通过钱包提供API进行交互了，这个要看具体钱包的要求，不同的钱包可能会有不同的初始化方式，具体要看他们的文档。比如这里就是 <a href="https://docs.metamask.io/guide/#why-metamask">MetaMask</a> 的文档。</p><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p>最大的好处在理想情况下（也就是用户用自己的 IPFS 节点和自己的区块链网关），这套技术是彻底的去中心化的，不需要某台服务器来提供服务。自然而然也享受到这些技术带来的好处，比如减少了单点失效的危险、高匿名、抗审查等。</p><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><p>但是这套系统结构还是面临了很多的不足，首先就是网关问题，大部分用户都无法提供上图提到的两种网关，其中 IPFS 的网关还可能自己搭建，但是区块链的网关让普通用户自己搭建会非常困难。这导致了，目前来说这两个网关还是非常中心化的，并没有体现出中心化的优势。</p><p>另外一个非常大的问题就是区块链的性能还是不行，吞吐量非常小而且不是可水平扩展（Scale-out）的。这导致上链的操作，可能有很长的延时和需要付很多的手续费。</p><p>另外用户要想使用 DApp 一般还需要安装钱包插件，对于不理解插件是什么的用户会很麻烦。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;DApp 也就是「Decentralized Application」的简称，按照很多营销号的说法是一个跨时代的技术。但是这东西其实远没有他们说的这么跨时代。这篇文章会从技术角度介绍一下什么是 DApp，以及它涉及到了哪些相关的技术，及其现阶段的问题有哪些，算是对我前段时间</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>IPFS 网络如何保存文件</title>
    <link href="http://blog.otakusaikou.com/2021/03/26/how-ipfs-save-files/"/>
    <id>http://blog.otakusaikou.com/2021/03/26/how-ipfs-save-files/</id>
    <published>2021-03-26T14:04:43.000Z</published>
    <updated>2023-04-15T01:24:06.259Z</updated>
    
    <content type="html"><![CDATA[<p>因为我经常写一些和 IPFS 相关的文章，我发现不了解 IPFS 的普通人经常问的一个问题是：「是不是我只要把文件上传到 IPFS 上，这个文件就能分布式保存、永不消失了？」。这个是个不易回答的问题，因为正确的答案是：「是也不是」。为了解释这个答案，我们需要了解一下 IPFS 网络是如何运作的。</p><p>假设下图是 IPFS 网络。</p><p><img src="/2021/03/26/how-ipfs-save-files/empty_network.png"></p><p>在 IPFS 网络中有三种操作：Add（添加）、Get（获取）以及 Pin（固定）。</p><p>假设我们使用 Add 操作，将一个文件添加到 IPFS 网络中之后，IPFS 网络会变成下面的样子。（我们用绿色来表示，一个 IPFS 节点里有文件的缓存）<br><img src="/2021/03/26/how-ipfs-save-files/added_network.png"></p><p>这个时候你只是将文件添加进了 IPFS 的缓存之中，当缓存满了以后，IPFS 会触发所谓的「GC（垃圾回收）」将多余的没有被「固定」的文件删除。所以如果你只是添加了文件没有固定文件而且还没有向别人分享文件的话，在触发垃圾回收之后，IPFS 网络又会变成空的状态了。<br><img src="/2021/03/26/how-ipfs-save-files/empty_network.png"></p><p>当然你也可以选择固定你缓存中的文件。固定完成之后，就不会被垃圾回收所删除了。（我们用蓝色来表示，IPFS 节点固定了某个文件）</p><p><img src="/2021/03/26/how-ipfs-save-files/pined_network.png"></p><p>这时候你就会问，那么这样不还是只有本地保存了文件，说好的分布式保存呢？对，确实没错。如果你想要 IPFS 的分布式发挥它的能力，你得分享你的文件。</p><p>当你分享了文件之后，有一部分人获取了这个文件之后 IPFS 网络的样子。<br><img src="/2021/03/26/how-ipfs-save-files/shared_network.png"></p><p>当然这些人中，可能会有人觉得这个文件对他也很重要，他也选择了固定这个文件。</p><p><img src="/2021/03/26/how-ipfs-save-files/shared_and_pined_network.png"></p><p>因为 IPFS 网络每个节点只要有缓存就可以帮助分发一个文件（实际上情况下，你的缓存里有这个文件的碎片就可以帮助分发，不一定需要完整的文件，因为不同文件可能会有相同的分块，这样可以加速整个网络和节约储存空间）。假设我们遇见一个情况，我们上传且分享了一个文件，但是一个不小心，弄丢了本地的IPFS缓存。也就是像这样。<br><img src="/2021/03/26/how-ipfs-save-files/lost_network.png"></p><p>但是因为这时 IPFS 网络中有其他的节点帮助你保存了这个文件，你仍旧可以重新获得这个文件。</p><p><img src="/2021/03/26/how-ipfs-save-files/fetched_network.png"></p><p>当然在这种情况下，即使文件最初的发布者不再拥有这个文件了，想要获取这个文件的人，也可以从其他节点那里获取到这个文件。（我们假设左上角的节点为最初的发布者）。<br><img src="/2021/03/26/how-ipfs-save-files/other_nodes_network.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因为我经常写一些和 IPFS 相关的文章，我发现不了解 IPFS 的普通人经常问的一个问题是：「是不是我只要把文件上传到 IPFS 上，这个文件就能分布式保存、永不消失了？」。这个是个不易回答的问题，因为正确的答案是：「是也不是」。为了解释这个答案，我们需要了解一下 IPF</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>IPFS 官方中文 Wikipedia 使用指南</title>
    <link href="http://blog.otakusaikou.com/2021/03/25/offical-wikipedia-ipfs-mirror-guide/"/>
    <id>http://blog.otakusaikou.com/2021/03/25/offical-wikipedia-ipfs-mirror-guide/</id>
    <published>2021-03-25T10:13:43.000Z</published>
    <updated>2023-04-15T01:24:06.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-IPFS？"><a href="#什么是-IPFS？" class="headerlink" title="什么是 IPFS？"></a>什么是 IPFS？</h2><blockquote><p><strong>星际文件系统</strong>（<strong>InterPlanetary File System</strong>，缩写<strong>IPFS</strong>）是一个旨在创建持久且分布式存储和共享文件的<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">网络传输协议</a>。它是一种<a href="https://zh.wikipedia.org/w/index.php?title=%E5%86%85%E5%AE%B9%E5%8F%AF%E5%AF%BB%E5%9D%80&action=edit&redlink=1">内容可寻址</a>的<a href="https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%AD%89%E7%B6%B2%E8%B7%AF">对等</a><a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E5%AA%92%E9%AB%94">超媒体</a>分发协议。在IPFS网络中的节点将构成一个<a href="https://zh.wikipedia.org/wiki/%E9%9B%86%E7%BE%A4%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">分布式文件系统</a>。它是一个<a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E6%94%BE%E6%BA%90%E4%BB%A3%E7%A0%81">开放源代码</a>项目，自2014年开始由<a href="https://zh.wikipedia.org/w/index.php?title=Protocol_Labs&action=edit&redlink=1">Protocol Labs</a>在开源社区的帮助下发展。其最初由<a href="https://zh.wikipedia.org/w/index.php?title=Juan_Benet&action=edit&redlink=1">Juan Benet</a>设计。</p></blockquote><p>用最简单的话来说 IPFS 是个 P2P 网络，和我们日常可能会使用的 BT 下载的原理类似，但是 IPFS 相比于 BT 来说做了非常多的改进，使得 IPFS 的性能和扩展性都有很大的提升。</p><p>在 IPFS 网络中每一个文件都有一个独特的 CID，当你把一个文件放入 IPFS 网络中，其他的用户就可以通过 CID 来获取到这个文件而不必考虑这个文件存放在何处。此外任何用户可以选择 pin 住一个文件的 CID，从而帮助 IPFS 网络长期的保存某个文件。</p><h2 id="什么是-Distributed-Wikipedia-Mirror？"><a href="#什么是-Distributed-Wikipedia-Mirror？" class="headerlink" title="什么是 Distributed Wikipedia Mirror？"></a>什么是 Distributed Wikipedia Mirror？</h2><p><a href="https://github.com/ipfs/distributed-wikipedia-mirror">Distributed Wikipedia Mirror</a> 是 IPFS 官方团队维护的一个项目。这个项目旨在将 Wikipedia 带入 IPFS 网络，以及最终构建出一个纯分布式的 Wikipedia。目前该项目已经提供了：英语、土耳其语、缅甸语和中文的 Wikipedia 镜像。</p><h2 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h2><p>本文将介绍如何使用中文版的 Wikipedia IPFS 镜像。</p><p>镜像的地址为:</p><ul><li>DNSLink: <code>zh.wikipedia-on-ipfs.org</code></li><li>CID: <code>bafybeiazgazbrj6qprr4y5hx277u4g2r5nzgo3jnxkhqx56doxdqrzms6y</code></li></ul><p><strong>请注意本项目的 CID 地址会随着分发的 Wikipedia 镜像版本更新而改变，你可以通过访问<a href="https://github.com/ipfs/distributed-wikipedia-mirror/blob/main/snapshot-hashes.yml">此地址</a>或者使用 <code>ipfs name resolve zh.wikipedia-on-ipfs.org</code> 获取到最新的 CID</strong> 。</p><p>我接下来会介绍3种不同的方式来访问本镜像。</p><hr><h3 id="公共网关"><a href="#公共网关" class="headerlink" title="公共网关"></a>公共网关</h3><p>公共网关是目前访问 IPFS 网络上内容最简单的方式，但这也是最容易被封锁的方式。我将以官方的网关为例来演示如何使用公共网关来访问 IPFS 网络上的内容。</p><p><strong>官方公共网关地址: <code>https://ipfs.io</code></strong></p><h4 id="使用-CID-访问镜像"><a href="#使用-CID-访问镜像" class="headerlink" title="使用 CID 访问镜像"></a>使用 CID 访问镜像</h4><p>如果你决定使用 CID 地址来访问镜像的话，你需要在浏览器地址栏按照如下格式输入:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://ipfs.io/ipfs/&lt;CID&gt;</span><br></pre></td></tr></table></figure><p>在我们的例子里就是：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://ipfs.io/ipfs/bafybeiazgazbrj6qprr4y5hx277u4g2r5nzgo3jnxkhqx56doxdqrzms6y</span><br></pre></td></tr></table></figure><h4 id="使用-DNSLink-地址访问"><a href="#使用-DNSLink-地址访问" class="headerlink" title="使用 DNSLink 地址访问"></a>使用 DNSLink 地址访问</h4><p>如果你决定使用 DNSLink 地址来访问镜像的话，你需要在浏览器地址栏按照如下格式输入:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://ipfs.io/ipns/&lt;DNSLink&gt;</span><br></pre></td></tr></table></figure><p>在我们的例子里就是：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://ipfs.io/ipns/zh.wikipedia-on-ipfs.org</span><br></pre></td></tr></table></figure><hr><h3 id="Brave-浏览器"><a href="#Brave-浏览器" class="headerlink" title="Brave 浏览器"></a>Brave 浏览器</h3><p>如果你在使用最新版的 <a href="https://brave.com/">Brave 浏览器</a>，你可以直接使用 Brave 内置的 IPFS 节点来访问 IPFS 网络上的内容。你在第一次使用 Brave 浏览器访问 IPFS 内容时，Brave 浏览器可能会询问你是否要启用本地 IPFS 节点，建议选择启用，如果没有启用，Brave 会自动使用公共网关来访问 IPFS 网络上的内容。此外你可以通过 Brave 设置页面中 IPFS 相关的选项和内置的 IPFS-Companion 插件中的选项来调整 IPFS 节点类型。</p><h4 id="使用-CID-访问镜像-1"><a href="#使用-CID-访问镜像-1" class="headerlink" title="使用 CID 访问镜像"></a>使用 CID 访问镜像</h4><p>如果你决定使用 CID 地址来访问镜像的话，你需要在浏览器地址栏按照如下格式输入:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipfs://&lt;CID&gt;</span><br></pre></td></tr></table></figure><p>在我们的例子里就是：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipfs://bafybeiazgazbrj6qprr4y5hx277u4g2r5nzgo3jnxkhqx56doxdqrzms6y</span><br></pre></td></tr></table></figure><h4 id="使用-DNSLink-地址访问-1"><a href="#使用-DNSLink-地址访问-1" class="headerlink" title="使用 DNSLink 地址访问"></a>使用 DNSLink 地址访问</h4><p>如果你决定使用 DNSLink 地址来访问镜像的话，你需要在浏览器地址栏按照如下格式输入:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipns://&lt;DNSLink&gt;</span><br></pre></td></tr></table></figure><p>在我们的例子里就是：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipns://zh.wikipedia-on-ipfs.org</span><br></pre></td></tr></table></figure><hr><h3 id="IPFS-Desktop"><a href="#IPFS-Desktop" class="headerlink" title="IPFS Desktop"></a>IPFS Desktop</h3><p>IPFS Desktop 对于是目前普通用户使用本地 IPFS 最容易的方法，你可以在<a href="https://github.com/ipfs-shipyard/ipfs-desktop/releases/latest">这里</a>下载最新版的 IPFS Desktop。在启动成功之后， IPFS-Dekstop 会默认在你本地地址的 <code>8080</code> 端口启动一个网关服务器，之后我们就可以使用这个本地的网关服务来访问 IPFS 网络上的内容了。</p><p>当然你可以通过修改 IPFS-Desktop 中的 <code>Gateway</code> 项，来修改默认的端口地址。</p><h4 id="使用-CID-访问镜像-2"><a href="#使用-CID-访问镜像-2" class="headerlink" title="使用 CID 访问镜像"></a>使用 CID 访问镜像</h4><p>如果你决定使用 CID 地址来访问镜像的话，你需要在浏览器地址栏按照如下格式输入:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:&lt;port&gt;/ipfs/&lt;CID&gt;</span><br></pre></td></tr></table></figure><p>在我们的例子里就是：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8080/ipfs/bafybeiazgazbrj6qprr4y5hx277u4g2r5nzgo3jnxkhqx56doxdqrzms6y</span><br></pre></td></tr></table></figure><h4 id="使用-DNSLink-地址访问-2"><a href="#使用-DNSLink-地址访问-2" class="headerlink" title="使用 DNSLink 地址访问"></a>使用 DNSLink 地址访问</h4><p>如果你决定使用 DNSLink 地址来访问镜像的话，你需要在浏览器地址栏按照如下格式输入:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:&lt;port&gt;/ipns/&lt;DNSLink&gt;</span><br></pre></td></tr></table></figure><p>在我们的例子里就是：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8080/ipns/zh.wikipedia-on-ipfs.org</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是-IPFS？&quot;&gt;&lt;a href=&quot;#什么是-IPFS？&quot; class=&quot;headerlink&quot; title=&quot;什么是 IPFS？&quot;&gt;&lt;/a&gt;什么是 IPFS？&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;星际文件系统&lt;/strong&gt;（&lt;stro</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>如何使用IPFS版的中文Wikipedia</title>
    <link href="http://blog.otakusaikou.com/2021/02/22/how-to-use-wikipedia-on-ipfs/"/>
    <id>http://blog.otakusaikou.com/2021/02/22/how-to-use-wikipedia-on-ipfs/</id>
    <published>2021-02-22T15:25:48.000Z</published>
    <updated>2023-04-15T01:24:06.263Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文内容已经废弃，请参照最新的《IPFS 官方中文 Wikipedia 使用指南》</strong></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>如果你熟悉 IPFS 的话，以下是地址</p><p>CID: <code>bafybeierrdxblmthjga6wap3tpk53icgzb7owstz5gbd6qxcy3kspktymm</code><br>IPNS: <code>k51qzi5uqu5dirl3inwnhrl6nicsaq9snlzg2aj7blt2komssvff4c9ln8tch3</code></p><h4 id="这是什么？"><a href="#这是什么？" class="headerlink" title="这是什么？"></a>这是什么？</h4><p>简单来说这是个用IPFS运行的中文版 Wikipedia 的镜像，这里的镜像用的是 Kiwix 提供的 <code>wikipedia_zh_all_maxi_2021-01</code> 版本镜像。IPFS 是一个类似 BT 的分布式文件系统，具体的介绍可以参照 Wikipedia 的「星际文件系统」条目。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>接下来的我会介绍三种使用方法，难度从易到难。</p><h4 id="公共网关"><a href="#公共网关" class="headerlink" title="公共网关"></a>公共网关</h4><p>目前来说使用公共网关来访问 IPFS 上的内容是最为简单的方法。</p><p>首先你需要找到一个公共网关的地址，我们以 IPFS 官方提供的公共网关举例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://ipfs.io</span><br></pre></td></tr></table></figure><p>接下来看你需要访问 CID 的内容还是 IPNS 的内容</p><p>如果是 CID：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://ipfs.io/ipfs/bafybeierrdxblmthjga6wap3tpk53icgzb7owstz5gbd6qxcy3kspktymm</span><br></pre></td></tr></table></figure><p>如果是 IPNS:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://ipfs.io/ipns/k51qzi5uqu5dirl3inwnhrl6nicsaq9snlzg2aj7blt2komssvff4c9ln8tch3</span><br></pre></td></tr></table></figure><p>当然官方提供的公共网关已经被墙了，你可以在访问<a href="https://contributionls.github.io/public-gateway-checker/?cid=bafybeierrdxblmthjga6wap3tpk53icgzb7owstz5gbd6qxcy3kspktymm">这里</a>寻找没有被墙的公共网关。</p><h4 id="Brave-浏览器"><a href="#Brave-浏览器" class="headerlink" title="Brave 浏览器"></a>Brave 浏览器</h4><p>目前 Brave 浏览器原生支持了 IPFS 链接，使用 Brave 浏览器访问 IPFS 上的内容也很简单。</p><p>首先你需要<a href="https://brave.com/">下载</a> Brave 浏览器，然后下载完成后，在你的地址栏里输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipfs://bafybeierrdxblmthjga6wap3tpk53icgzb7owstz5gbd6qxcy3kspktymm</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipns://k51qzi5uqu5dirl3inwnhrl6nicsaq9snlzg2aj7blt2komssvff4c9ln8tch3</span><br></pre></td></tr></table></figure><p>第一次访问 IPFS 的链接 Brave 可能会问你要不要使用本地 IPFS 节点，建议选择使用，如果不使用本地节点，Brave 会自动 fallback 到公共网关。</p><h4 id="IPFS-Desktop"><a href="#IPFS-Desktop" class="headerlink" title="IPFS-Desktop"></a>IPFS-Desktop</h4><p>IPFS-Desktop 是 IPFS 官方开发的一款 IPFS 的图形化操作软件，你可以在<a href="https://github.com/ipfs-shipyard/ipfs-desktop/releases/latest">这里</a>下载到最新版。</p><p>在你下载启动 IPFS-Desktop 之后，IPFS 会自动监听<code>127.0.0.1:8080</code>作为本地的网关。</p><p>所以你可以打开你日常使用的浏览器输入（你可以安装 <a href="https://github.com/ipfs-shipyard/ipfs-companion">IPFS- Companion</a> 插件来方便访问）:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8080/ipfs/bafybeierrdxblmthjga6wap3tpk53icgzb7owstz5gbd6qxcy3kspktymm</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8080/ipns/k51qzi5uqu5dirl3inwnhrl6nicsaq9snlzg2aj7blt2komssvff4c9ln8tch3</span><br></pre></td></tr></table></figure><p>来访问。</p><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><p>本中文 Wikipedia 只是一个静态的镜像，无法添加新的内容，另外目前也不支持搜索功能。不过你可以通过自己改变URL来访问不同的页面，比如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipfs://bafybeierrdxblmthjga6wap3tpk53icgzb7owstz5gbd6qxcy3kspktymm/wiki/计算机科学</span><br></pre></td></tr></table></figure><p>你只需要改变链接 <code>wiki</code> 后面的名字就能访问不同的页面。</p><h2 id="这个项目是如何持续的？"><a href="#这个项目是如何持续的？" class="headerlink" title="这个项目是如何持续的？"></a>这个项目是如何持续的？</h2><p>这个项目是完全免费的，现在也是之后也是，随着用户的增多这个项目消失的可能性也就越小。如果你愿意帮助分发本项目或者想自己建立一个镜像请看之后的链接。但是目前维护这个项目每个月还是会有一定的成本。目前这个成本我可以自己承担，另外我也持有了一定的 FileCoin（IPFS 上层的激励币，另外这个不是投资建议，请不要盲目投资加密货币），如果你希望这个项目可以长期维持，我非常建议你了解甚至开发 IPFS 相关的项目，这样我手上的 FileCoin 就可以升值了，也就可以抵消相关的成本了。</p><p>另外我也接受虚拟货币的捐款。</p><p>FileCoin 捐款地址: <code>f1sbsblwklyr4drmi3ajzez5vglgvpwxudgtuyqqy</code></p><h2 id="如何帮助分发和如何建立自己的镜像"><a href="#如何帮助分发和如何建立自己的镜像" class="headerlink" title="如何帮助分发和如何建立自己的镜像"></a>如何帮助分发和如何建立自己的镜像</h2><p>请参照我写的<a href="https://blog.otakusaikou.com/2021/02/09/wikipedia-on-ipfs-tutorial/">另一篇文章</a>.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;本文内容已经废弃，请参照最新的《IPFS 官方中文 Wikipedia 使用指南》&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;如果你熟</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>如何在IPFS上部署Wikipedia</title>
    <link href="http://blog.otakusaikou.com/2021/02/09/wikipedia-on-ipfs-tutorial/"/>
    <id>http://blog.otakusaikou.com/2021/02/09/wikipedia-on-ipfs-tutorial/</id>
    <published>2021-02-09T17:33:19.000Z</published>
    <updated>2023-04-15T01:24:06.315Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在 IPFS 上部署 Wikipedia 的原理相当的简单，主要利用了 <a href="https://wiki.kiwix.org/wiki/Main_Page/zh-cn">Kiwix</a> 提供的离线版 Wikipedia 文件，将其解压并转换成静态文件之后就可以放到 IPFS 上了。这里我们主要依靠了 IPFS 团队提供的 <a href="https://github.com/ipfs/distributed-wikipedia-mirror">distributed-wikipedia-mirror</a> 项目以及 OpenZIM 团队提供的 <a href="https://github.com/openzim/zim-tools">ZIM-Tools</a> 工具，同样也非常感谢 IPFS 和 OpenZIM 团队在我折腾过程中给我提供的帮助。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>目前来说整个过程只能在 AMD64 Linux 上完成，主要是 ZIM-Tools 项目目前还没有在其他系统下的构建。我们将以中文版的 Wikipedia 为例。这个过程大概会消耗你大约 90G 左右的空间，所以请至少保证你的磁盘有大约 100G 左右的余量，此外这个大小会随着中文 Wikipedia 的内容增加而增长，另外你还在保证你的部署系统有至少4G的内存（我不清楚调整OOM相关的设置可不可以缓解这个问题，从而实现在小容量内存上的使用，不过我还是建议加大内存）。</p><p>首先你肯定需要一个 IPFS 的节点，这里不介绍 IPFS 节点的搭建了。除此之外为了能在 IPFS 托管 Wikiepedia，我们还需要启用几个IPFS的实验特性，这里我们以 <code>go-ipfs</code> 作为 IPFS 节点软件。</p><p>你可以通过<code>IPFS_PATH</code>环境变量来指定IPFS仓库的位置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> IPFS_PATH=/somewhere</span><br></pre></td></tr></table></figure><p>其次建议使用 <code>badgerds</code>数据来存放数据，从而提升性能</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipfs init -p badgerds --empty-repo</span><br></pre></td></tr></table></figure><p>首先我们需要启用 <code>Experimental.ShardingEnabled</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipfs config --json <span class="string">&#x27;Experimental.ShardingEnabled&#x27;</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这个选项解除了一个文件夹内可以存放文件数量的限制，你可以在<a href="https://github.com/ipfs/go-ipfs/blob/master/docs/experimental-features.md">这个页面</a>找到 <code>go-ipfs</code> 的所有实验性特性的说明和配置。</p><p>然后你得保证你的电脑上安装了 <code>Cargo</code>、<code>Nodejs</code>、<code>yarn</code>、<code>git</code>以及一系列的构建工具（也就是 Debian 系的 <code>build-essential</code> 包中的工具）。</p><p>接下来你需要克隆并且进入 <a href="https://github.com/ipfs/distributed-wikipedia-mirror">distributed-wikipedia-mirror</a>  项目。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/ipfs/distributed-wikipedia-mirror &amp;&amp; <span class="built_in">cd</span> distributed-wikipedia-mirror</span><br></pre></td></tr></table></figure><p>然后输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn</span><br></pre></td></tr></table></figure><p>来构建配置环境。</p><p>因为我们之后需要用到 <a href="https://github.com/openzim/zim-tools">ZIM-Tools</a> 来解压我们下载完成的 ZIM 文件，所以我们预先下载好 ZIM-Tools，这里我们以 2.1.0 为例，你可以在这里找到 ZIM-Tools 预编译的二进制包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.openzim.org/release/zim-tools/zim-tools_linux-x86_64-2.1.0.tar.gz</span><br><span class="line">tar -xf zim-tools_linux-x86_64-2.1.0.tar.gz</span><br><span class="line"><span class="built_in">mv</span> zim-tools_linux-x86_64-2.1.0 zim</span><br></pre></td></tr></table></figure><p>接下来需要下载 ZIM 文件，ZIM 文件是一种离线版 Wikipedia 保存格式。</p><p> <a href="https://github.com/ipfs/distributed-wikipedia-mirror">distributed-wikipedia-mirror</a> 项目默认提供了一种直接下载的方式，你可以输入:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash ./tools/getzim.sh cache_update</span><br><span class="line">bash ./tools/getzim.sh choose</span><br></pre></td></tr></table></figure><p>进入选择菜单输入数字选择，比如你要中文版的全量 Wikipedai 的 ZIM文件，你可以选择<code>[12] wikipedia =&gt; [294] zh =&gt; [0] all =&gt; [0] maxi =&gt; [0] latest</code> 来获取到最新的中文 Wikipedia 全量 ZIM 文件，下载完成后默认存放在  <code>snapshots</code> 文件夹中。</p><p>当然因为下载服务在海外，如果你想在国内的机器上配置的话，我更推荐使用 BitTorrent 的方式来下载，这里我们将以 <code>wikipedia_zh_all_maxi_2021-01.zim</code> 为例，你可以<a href="https://wiki.kiwix.org/wiki/Content_in_all_languages">在这里</a>获取到所有语言的 BitTorrent 种子文件。</p><p>为了方便起见我们这里直接使用了<code>aria2</code> 来进行 BitTorrent 下载。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.kiwix.org/zim/wikipedia_zh_all_maxi.zim.torrent </span><br><span class="line">aria2c wikipedia_zh_all_maxi.zim.torrent -d snapshots</span><br></pre></td></tr></table></figure><p>在下载完毕之后我们需要解压 zim 文件，在我们的例子里就是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> tmp</span><br><span class="line">./zim/zimdump dump ./snapshots/wikipedia_zh_all_maxi_2021-01.zim --<span class="built_in">dir</span> ./tmp/wikipedia_zh_all_maxi_2021-01</span><br></pre></td></tr></table></figure><p>这个解压过程会很漫长，并且会消耗大量的磁盘空间，以我的体验来说，zim文件的压缩比大概是 4:1，也就是 1G 的 ZIM 文件大概会解压出 4G 的原始文件。</p><p>在解压完毕之后，我们还需要稍微处理一下解压好的文件，这样才能让用户正常的浏览网页。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node ./bin/run ./tmp/wikipedia_zh_all_maxi_2021-01 \</span><br><span class="line">  --zimfilesourceurl=https://download.kiwix.org/zim/wikipedia_zh_all_maxi.zim \</span><br><span class="line">  --kiwixmainpage=User:The_other_Kiwix_guy/Landing \</span><br><span class="line">  --mainpage=Wikipedia:%E9%A6%96%E9%A1%B5</span><br></pre></td></tr></table></figure><p>这里的 <code>--zimfilesourceurl</code>、<code>--kiwixmainpage</code>、<code>--mainpage</code> 是三个必须选项，这里还有其他的选择可以选择，你可以输入如下命令查看所有的选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node ./bin/run -h</span><br></pre></td></tr></table></figure><p>上面我们填的三个参数的作用分别是</p><ul><li><code>--zimfilesourceurl</code>：指定 ZIM 文件的下载地址</li><li><code>--kiwixmainpage</code>：Kiwix 的默认主页是什么，中文 Wikipedia 这里的值是 <code>User:The_other_Kiwix_guy/Landing</code></li><li><code>--mainpage</code>：网页版 Wikipedia 的默认主页是什么，中文 Wikipedia 这里的值是<code>Wikipedia:%E9%A6%96%E9%A1%B5</code></li></ul><p>之后应该就会在之前的解压目录中生成<code>index.html</code>等文件，来让用户可以向访问正常网页一样访问了。</p><p>在添加文件之前我们需要提升一下系统的可打开文件数量，不然中途会失败。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ulimit -a</span><br><span class="line">ulimit -n 8096</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipfs add -r --cid-version 1 ./tmp/wikipedia_zh_all_maxi_2021-01/</span><br></pre></td></tr></table></figure><p>这个过程可能会持续大约50个小时（我的部署），建议用类似<code>screen</code>的软件保证部署不会中断。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;p&gt;在 IPFS 上部署 Wikipedia 的原理相当的简单，主要利用了 &lt;a href=&quot;https://wiki.kiwix.org/wi</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>命名数据网络，一个未来网络的可能性</title>
    <link href="http://blog.otakusaikou.com/2021/01/19/named-data-networking-a-feature-network/"/>
    <id>http://blog.otakusaikou.com/2021/01/19/named-data-networking-a-feature-network/</id>
    <published>2021-01-19T19:35:48.000Z</published>
    <updated>2023-04-15T01:24:06.263Z</updated>
    
    <content type="html"><![CDATA[<p>我们的故事要回到 1974 年，彼时计算机主要形式还是大型机，创造计算机行业历史的 Apple I 要在两年后才正式面世，而我们熟知的万维网（World Wide Web）在整整十五年后才会被伯纳斯-李爵士在他的《关于信息化管理的建议》中提出。在那时我们现在使用的互联网还未出现，当时有的只是「阿帕网」——一个仅有4个节点构成的小型网络。而在 1973 的夏天到 1974 年的这段时间，来自康涅狄格州和出身自纽约的犹太人家庭的两位年轻人，他们在斯坦福的网络研究组里设计和开发出了一个叫做 <strong>TCP&#x2F;IP</strong> 协议。正如上帝要把祂的教会建立在磐石之上在，TCP&#x2F;IP 协议最后也成了我们网络世界的「磐石」。这两位年轻人：文顿·瑟夫和罗伯特·卡恩，也在三十年后的 2004 年，获得了计算机科学领域最贵重的那只碗——图灵碗。</p><p>当然我们的故事还要继续，在几乎同一时期的中国大陆，一位叫做张丽霞的年轻女性受到了文革的影响，正在田野中开着拖拉机。她在文革结束后来到了美国，并在美国获取了硕士和博士学位。后来她在 1986 年作为 21 人中唯一的女性和唯一还是学生身份的人的参加了第一次的互联网工程任务组会议。而这个「小组」最后成长为了一个负责互联网规范制定与研发的庞大组织。在几年后范·雅各布森， TCP&#x2F;IP 协议最初的起草者中的其中一位，重新设计了 TCP&#x2F;IP 的流控制算法，并和他人一起合作编写了一系列如今软件工程师们仍在使用的网络工具：traceroute、pathchar 以及 tcpdump。在 2006 年 8 月的 Google Tech Talk 上做了一个叫做《<a href="https://www.youtube.com/watch?v=oCZMoY3q2uM">A New Way to look at Networking</a>》的演讲，在这个演讲中，他提出了一个名叫「Named Data Networking」的全新的网络架构，并在此后的多年里和张丽霞教授一起领导着这个项目的研究。而这个项目正是我们今天的主角：命名数据网络，简称 NDN 网络。</p><p>为了理解什么是命名数据网络，以及命名数据网络为什么重要，我们得先理解现有的 TCP&#x2F;IP 网络的模型是什么样子的，我们先从 TCP&#x2F;IP 网络的定义着手。</p><blockquote><p>TCP&#x2F;IP 提供了点对点连结的机制，将资料应该如何封装、定址、传输、路由以及在目的地如何接收，都加以标准化。</p><p>——<a href="https://zh.wikipedia.org/zh-hans/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F">Wikipedia</a></p></blockquote><p>这句话中的「点对点」的意思是，在 TCP&#x2F;IP 模型中，设备获取内容的主要方式是从另一台计算机那里下载。当然这么说还是很复杂，我们来看一个详细的例子。</p><p>首先我们要明白，在 TCP&#x2F;IP 模型中，在一个网络中每一个计算机都有一个独属于它的 IP 地址，而计算机则是用 IP 地址来表联系网络中另一台计算机。任意一台计算机上的资源都可以表示为下面的形式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file://119.23.141.248/index.html</span><br></pre></td></tr></table></figure><p>上面描述了一台 IP 地址为 <code>119.23.141.248</code> 的计算机上的一个叫做 <code>index.html</code> 的文件，这里的 <code>file://</code> 只是一个前缀标识而已，不用过于在意。而其他的计算机要获取这个文件必须要向这台计算机发送请求，与这台计算机建立一个传输数据的通道，然后才能开始正式传输数据。</p><p>可以看到在 TCP&#x2F;IP 模型中，IP 地址是寻找内容时的核心，而「通道」则是传输内容的核心。但是如果你仔细想想，我们想要的只是获取获取到这个 <code>index.html</code> 文件而已，其实并不想也并不需要关心这个文件具体存放在什么地方。而我们也不想关心通道，我们只是想要内容而已。</p><p>那么这个模型有什么问题呢？想象下面这个情况。</p><p><img src="/2021/01/19/named-data-networking-a-feature-network/image-20210119184048547.png" alt="多台计算机连接同一台计算机获取同一个资源文件"></p><p>在上面这张图中，描绘了一个多个计算机访问一台计算机上内容的情况。在这个过程中，虽然下方的每台计算机都是想要获取同一个 <code>index.html</code> 文件，但是他们都需要访问这台地址为 <code>119.23.141.248</code> 的计算机并与这台计算机建立通道。这会重复的消耗这台计算机的网络资源，这显然是不高效的。而访问同一个文件会重复消耗计算机资源现象，也导致了现在网络世界中 DDOS 攻击泛滥。</p><p>最糟糕的是下面这种情况。</p><p><img src="/2021/01/19/named-data-networking-a-feature-network/image-20210119184128701.png" alt="偷窥者正在偷窥通道"></p><p>想象除了这些计算机外，出现了一个偷窥者，这个偷窥者用某种我们不知道的方法，可以看见并且修改这个通道内的内容。那么这些正在获取 <code>index.html</code> 文件的计算机们是没有办法能够验证这些内容是不是被修改过的。他们能做的只是想尽办法加密这个通道。而这就是为什么我们现在有了 HTPPS。</p><p>而命名数据网络则解决了这些问题。在 NDN 网络中，我们不再需要关心地址，管道等一堆破烂事。我们只需要关心我们最想要关心的一样东西：数据。而我们获取数据的方式则是通过这个数据的「名字」，这也是「命名数据网络」这个名字的来源。在大部分情况下，这个「名字」会是数据的哈希值。哈希值是数据唯一的名字，只要这个数据发生了任何的变化，它的哈希值都会发生改变。所以我们可以利用这个特性来验证我们获取到的数据有没有被篡改过，这样就消除了偷窥者修改数据的可能性。</p><p><img src="/2021/01/19/named-data-networking-a-feature-network/image-20210119184605146.png" alt="命名数据网络的架构"></p><p>而当你不用再关心你要的数据存放在哪里的时，你就会发现，只要是数据是你要的数据，哪怕这个数据不是从最初的发布者那里来的也没关系。比如在上图中，计算机 A 如果想要文件 <code>index.html</code> ， 而计算机 C 之前从最初的发布者 D 那里获取过同样的文件，计算机 A 其实可以直接从 C 那里拿文件，而并不一定要从 D 那里拿文件。当然其实在大部分时候 C 其实是路由器，如果对具体的原理感兴趣可以看张丽霞教授的一个<a href="https://youtu.be/uoT7I4QlNEg">演讲</a>。</p><p>除此之外，命名数据网络还有很多其他的好处，但是因为篇幅所限，更多详细的细节比如：命名数据网络在物联网中的优势，具体数据包的种类，路由是如何传播的等，都可以去看我上面提到的张丽霞教授的演讲。</p><p>命名数据网络在提出之后，启发了一个全新的计算机网络的领域，这个领域被称作 Information-centric networking（信息中心网络），而这个领域的研究成果很可能在未来重塑我们的网络世界。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们的故事要回到 1974 年，彼时计算机主要形式还是大型机，创造计算机行业历史的 Apple I 要在两年后才正式面世，而我们熟知的万维网（World Wide Web）在整整十五年后才会被伯纳斯-李爵士在他的《关于信息化管理的建议》中提出。在那时我们现在使用的互联网还未</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>一个去中心化的网络论坛设计</title>
    <link href="http://blog.otakusaikou.com/2021/01/03/a-decentralized-internet-forum-desgin/"/>
    <id>http://blog.otakusaikou.com/2021/01/03/a-decentralized-internet-forum-desgin/</id>
    <published>2021-01-03T21:50:25.000Z</published>
    <updated>2023-04-15T01:24:06.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文讲介绍了一个基于 IPFS 去中心化论坛的设计，虽然用的 IPFS 技术，但是实际上这个设计也可以用于别的技术栈。同时这是个非常简单的设计，中间有很多可以优化的空间，本设计只为了读者提供思路。</p><h2 id="技术背景介绍"><a href="#技术背景介绍" class="headerlink" title="技术背景介绍"></a>技术背景介绍</h2><p>为了后续内容的阅读体验，我将对本设计涉及到的技术—— IPFS，做一个简单的介绍，当然这个介绍不会深入 IPFS 网络的细节，只是对 IPFS 这个抽象层的介绍，另外为了读者的阅读考虑，我尽量少引用术语，如果读者对 IPFS 网络的细节感兴趣，可以自行阅读 IPFS 的<a href="https://docs.ipfs.io/">文档</a>。</p><p><a href="https://ipfs.io/">IPFS</a>（InterPlanetary File System）又名星际文件系统，在一般的介绍里可能会说它是个「硬盘共享协议」，但我觉得它其实更像是个文件分享协议，如果你了解 BT 协议的话，IPFS 网络和 BT 网络是非常相近的。</p><p>在你加入 IPFS 网络之后，你和 IPFS 其他的节点一起构成一个内容存储的网络。在这个网络中，你上传到所有文件（或者文件夹）都有一个独一无二的 ID，称为 CID （Content Identifier)，你不需要知道这个 CID 是如何生成的，你可以直接把这个 CID 直接理解为文件的 Hash 值（类似 BT 网络中的磁力链接），也正是因为如此当你修改文件内容时候 CID 也会随之改变。通过 CID IPFS 可以实现文件的去重，也就是它不会存储 CID 相同的文件。当你需要获取一个文件时候，如果这个网络中有人缓存了这个文件且在线，你可以直接通过这个 CID 获取到你想要文件。</p><p>但是这个不可变性也带来了问题，如果我们需要一个可变的内容该怎么办？举例来说，我们想要发布一个静态网站到 IPFS 网络上，我们不可能每次在更新网页之后都给用户提供一个新的 CID 地址，用户需要一个固定的地址来访问我们的网站。而解决这个问题的办法就是 <a href="https://docs.ipfs.io/concepts/ipns/">IPNS</a>（InterPlanetary Name System）。你不用在意这个 IPNS 是如何如何实现的，你只需要知道，我们可以通过一个固定 IPNS 地址来访问最新的内容就行，当然你之前的内容如果有人缓存的话也会停留在IPFS网络上，但是如果没人缓存或者缓存内容的人不在线，那么之前的内容就会丢失了。</p><p>下面就是一个例子，你可以看到我们把 CID 为<code>QmSwMfsNFmUxn5D2BcHU2NGkuKoAEAaowdJ6Qdn9w1j8ev</code> 绑定到了<code>k2k4r8mu68txggqrlfp3zylq5rvabpgdhjz3uop2813at3g7xn3rbc3a</code>这个 name 上，当然我们也可以更新这个 name 绑定的 CID 。</p><p>不过 IPNS 并不是唯一实现这个功能的协议，这里只是为了方便所以使用了这个协议，其他类似的协议还有有，比如说 <a href="https://docs.ipfs.io/concepts/dnslink/#publish-using-a-subdomain">DNSLink</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ipfs name resolve k2k4r8mu68txggqrlfp3zylq5rvabpgdhjz3uop2813at3g7xn3rbc3a</span><br><span class="line">/ipfs/QmSwMfsNFmUxn5D2BcHU2NGkuKoAEAaowdJ6Qdn9w1j8ev</span><br></pre></td></tr></table></figure><p>以上就是这个设计所需要用到的技术的简单介绍。</p><h2 id="具体设计"><a href="#具体设计" class="headerlink" title="具体设计"></a>具体设计</h2><p>首先说明，这个设计基于一个最理想的情况，也就是所有用户都一直在线且会保存自己的文件，现实世界不一定如此。另外这只是一个初步的设计，肯定会有很多不完善的地方。此外为了简单起见，我们将用户的「回复」也作为「帖子」处理。</p><p><img src="/./network.jpg" alt="network"></p><p>在这个网络中，有两类节点，请注意这里的每个节点都有 IPNS 地址：</p><ul><li>论坛节点</li><li>用户节点</li></ul><p>其中「论坛节点」是这个论坛系统运作的核心，而这个节点中最为重要的文件就是 <code>users.csv</code> ，其具体内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ipns1,users1_id</span><br><span class="line">ipns2,users2_id</span><br><span class="line">ipns3,users3_id</span><br></pre></td></tr></table></figure><p>在这个文件中，记录了一系列的 IPNS 地址，这里的每一个 IPNS 地址指向了一个用户的发帖文件夹，而 <code>user_id</code> 则是用户的标识符，这里可以充当标识符的内容有很多比如：用户名、用户的公钥等。而用户注册这个论坛的方式，也就是向这个文件中加入一条记录，具体的注册方式有很多不同的解决方案，比如论坛的维护者可以做一个简单的网页来让用户注册。</p><p>而「主题文件」是作为发帖分类用的，具体的使用方式见下文。</p><p>在「用户节点」，用户需要创建一个文件夹，并在在这个文件夹内存放自己帖子，你在这个文件夹中添加新的文件就相当于发帖。用户需要按照以下协议进行发帖。</p><p>用户发帖格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Preview_CID:[回复/帖子/主题的CID,] </span><br><span class="line">Date:Unix时间戳</span><br><span class="line">File_Type:plain</span><br><span class="line">Title:</span><br><span class="line">Lorem ipsum </span><br><span class="line">Content:</span><br><span class="line">Lorem ipsum dolor sit amet, consectetur adipiscing elit. </span><br><span class="line">Pellentesque vitae scelerisque purus. Curabitur sed lectus ut sapien sodales hendrerit.</span><br></pre></td></tr></table></figure><p>这个格式主要分为两个区域： <code>Meta</code> 区域和 <code>Content</code> 区域</p><ul><li><code>Meta</code> 区域主要记录的发帖的「元信息」比如是个「新帖子」还是「回复」，要回复谁或者要发到哪个分类下。</li></ul><p>在这个分类中有一个 <code>Preview_CID</code>，它接受一个 CID 组成的数组，这里的 CID 可以是某个帖子、回复或者论坛提供的主题的 CID。</p><ul><li><code>Content</code> 区域主要记录发帖的内容，比如帖子的标题和内容等。</li></ul><p>在这个分类中  <code>Title</code> 表示帖子的的标题，而 <code>Content</code> 表示帖子的具体内容。</p><p>用户在发布一个新的「帖子」之后，需要更新自己的 IPNS 地址的绑定来添加新的内容。</p><p>而用户获取他人帖子的具体步骤如下，首先去论坛节点的 IPNS 地址获取到最新的 <code>users.csv</code>，然后根据这个列表上的其他用户的 <code>IPNS</code> 地址获取到其他用户的最新发帖，最后根据用户发帖中的 <code>Preview_CID</code> 信息将讨论串拼接起来。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>首先我还是得重复一下，这个是个非常简单的设计，中间肯定会有非常多可以优化的地方。</p><p>在这个设计中，你发的所有帖子都是先存放在本地，当别人需要的时候才会被同步出去，这意味着你不用担心你的贴文内容会被「论坛」所控制，也不会因为某天论坛消失了，你得发的内容也消失了。此外因为 IPFS 网络的特性，你只要能连上 IPFS 网络，你就可以获取到 <code>users.csv</code> ，这样也解决了因为你所在的公司、地区和国家进行了网络封锁导致你无法访问的论坛的问题。</p><p>上面看上去都是这个这个分布式论坛看得到的好处，我觉得看不到的好处也很重要，因为它很有趣，这是个基本上没多少先例的领域，创造之前没有人做过的东西总是很有趣的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;本文讲介绍了一个基于 IPFS 去中心化论坛的设计，虽然用的 IPFS 技术，但是实际上这个设计也可以用于别的技术栈。同时这是个非常简单的设</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>软件工程师装屄指南</title>
    <link href="http://blog.otakusaikou.com/2020/11/19/how-to-become-a-poser/"/>
    <id>http://blog.otakusaikou.com/2020/11/19/how-to-become-a-poser/</id>
    <published>2020-11-19T10:25:38.000Z</published>
    <updated>2023-04-15T01:24:06.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="免责说明"><a href="#免责说明" class="headerlink" title="免责说明"></a>免责说明</h2><p>首先说明，本文是戏文，并没有实际映射到到某个人，如果你发现有些人能对号入座，那我倍感荣幸。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在现在的互联网上，你总是能在各种的广告、书籍的腰封和社交媒体上看到各式各样的人在称呼各种各样的人为「大神&#x2F;大佬&#x2F;牛人」。我对这些称呼并无好感，而且这也不是本文的重点，本文的重点是：如何让你成为一个这样的人。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在要开始成为这些人之前，你得先做点准备工作，确切的来说你得准备一下你的背景。为了让人在第一印象中觉得你很牛屄，一个精心准备的背景是必不可少的。那么接下来的问题就是，怎么样才算得上是个「精心准备的背景」呢？答案很简单，就和你写工作简历一样，突出你之前相对来说做的好的地方。当然在互联网上宣传自己，还是和写简历有所区别。</p><ol><li>学习经历，如果你有海外名校或者国内名校的学习经历，可以写上，如果没有就不用写了</li><li>工作经历，这里和写简历不同，你不需要突出你具体干了哪些事，可以直接写公司名称，借着公司招牌宣传自己</li><li>项目经历，有最好，如果没有一个非常牛屄项目经历就不用写了，当然如果你是某个著名开源项目的贡献者，你可以写上。</li></ol><p>总儿言之这里的关键点是「借者别人的名号宣传自己」。换句话说，你要想尽办法拉起别人的大旗，哪怕这个旗和你只有一点点沾边。</p><h2 id="培养名声"><a href="#培养名声" class="headerlink" title="培养名声"></a>培养名声</h2><p>有了背景之后，接下来就需要培养名声了。其实这里应该还有做角色定位的一步，但是我觉得一个人不能做不符合自己内心的事太久，所以按照你的喜好来就行。</p><p>那么接下的问题就是如何培养名声。首先要选择你的话题，选择话题的第一要点是要选你喜欢的立场，其次是要选择大家都关心的事，另外这里你还得选择和大部分看法相反的立场或者相近的立场，中间派是没法快速收获名声的，具体怎么选就看你怎么想了。</p><p>在互联网上，收集名声最好的方法还是写文章，当然我知道对于大部分的软件工程师来说，写文章还是过于的困难了。所以这里有个简便的方法，也就是所谓的「洗稿」。当然，如果你洗中文世界的稿，先不说别人会不会来找你，光是中文世界文章这个落后性，你就赚取不了名声。所以，你可以洗英文世界的稿件。你需要做的就是到类似 Hacker News 的网站上，找一些话题相同的文章，半翻译，半插入几句自己观点的方式，将其变成一篇中文的稿件。</p><p>有了稿件之后，下一步就是如何发布这些稿件，非常简单，去各种社交媒体上发布就行，什么知乎，微信公众号，当然作为软件工程师你的博客上也需要有一份。什么，你说你是在文章里反对微信的，不想到微信公众号里发文章。别闹了，流量才是关键，大家看的是个情绪，谁管你是真做还是假做。哪怕有人指责你，你也可以写点不痛不痒的话圆回来。</p><p>当然另一个好的办法就是通过类似微博或者推特的平台收集名声。你只需要稍微转发几条英文的新闻，别忘了加上一些看上去有道理的评论，粉丝名气自然而然的就来了。不过这种转发效应太慢，还是写文章来的快。</p><h2 id="公关"><a href="#公关" class="headerlink" title="公关"></a>公关</h2><p>随着时间的积累，你肯定会收获一点名气，于此同时也肯定会有一些人来批评你。对于这些人解决方法有两种：如果他比起你来没什么名气，你直接拉黑，屏蔽一条龙就行。如果批评你的人比起你的名气要大很多，那么就是坚决斗到底，这样你你还可以吸引一批不喜欢对方的人。</p><p>另外，在收获名声的过程中，你还得学会抱大腿，加入各种名人的圈子，这样别人有意无意的带上你，你也可以收获大批粉丝。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;免责说明&quot;&gt;&lt;a href=&quot;#免责说明&quot; class=&quot;headerlink&quot; title=&quot;免责说明&quot;&gt;&lt;/a&gt;免责说明&lt;/h2&gt;&lt;p&gt;首先说明，本文是戏文，并没有实际映射到到某个人，如果你发现有些人能对号入座，那我倍感荣幸。&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>X86 软路由配置 IPv6 踩坑小记</title>
    <link href="http://blog.otakusaikou.com/2020/11/11/x86-soft-router-and-ipv6/"/>
    <id>http://blog.otakusaikou.com/2020/11/11/x86-soft-router-and-ipv6/</id>
    <published>2020-11-11T12:46:28.000Z</published>
    <updated>2023-04-15T01:24:06.315Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景故事"><a href="#背景故事" class="headerlink" title="背景故事"></a>背景故事</h2><p>这一次踩坑之旅的起源是一段来自内核恐慌 Telegram 群的关于 IPv6 的讨论，<a href="https://twitter.com/RioJot">Rio</a> 发了关于他配置 IPv6 时候的踩坑<a href="https://www.v2ex.com/t/722411">帖子</a>，而我正好一直想把家里软路由的 IPv6 配置起来，就有了这一次经历。这里非常感谢 Rio 和听众群的朋友，没有他们的帮助也就没有这次的经历。</p><h2 id="关于-IPv6-的小介绍"><a href="#关于-IPv6-的小介绍" class="headerlink" title="关于 IPv6 的小介绍"></a>关于 IPv6 的小介绍</h2><p>在开始配置环境之前，我想先做一个关于 IPv6 的小介绍。介绍一下之后会涉及到的一些概念，比如：RA，slaac 等。这个介绍不会涉及到 IPv6 整体是怎么工作的，主要介绍一下在 IPv6 设备是如何获取 IPv6 地址的。</p><p>在开始介绍在 IPv6 环境之前，得先介绍一下什么是 RA。RA 也就是：Router Advertisement（路由器通告报文）是一种 ICMPv6 报文，ICMP 也就是我们日常 Ping 命令使用的报文。在 IPv6 点环境中路由发出的 RA 会携带一系列的信息告知设备如何配置自己的 IP 地址。</p><p>在 IPv6 中有多种自动配置 IP 的方式，这里我们只会接触到 slaac 和 DHCPv6，下面有个关于这两种方式区别的解释。</p><blockquote><p><strong>其中“自动配置”根据获取方式，又分为</strong></p><p>▷ 无状态（Stateless）：根据路由通告报文RA（Router Advertisement）包含的prefix前缀信息自动配置IPv6地址，组成方式是Prefix + (EUI64 or 随机)。Stateless也可以称为SLAAC（Stateless address autoconfiguration）</p><p>▷ 有状态（Stateful）：通过DHCPv6方式获得IPv6地址</p><p>——<a href="https://cloud.tencent.com/developer/article/1517325">IPv6系列-详解自动分配IPv6地址</a></p></blockquote><p>因为安卓设备只支持 slaac，所以我使用了 slaac 方式配置局域网内设备的IP。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>我这里使用系统是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux version 4.19.0-9-amd64 (debian-kernel@lists.debian.org) (gcc version 8.3.0 (Debian 8.3.0-6)) #1 SMP Debian 4.19.118-2+deb10u1 (2020-06-07)</span><br></pre></td></tr></table></figure><p>机器本身是一台四个网口的软路由。</p><p>上网方式是 PPPoE 拨号上网</p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>首先配置网卡。</p><p><code>/etc/network/interfaces</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">source /etc/network/interfaces.d/*</span><br><span class="line"></span><br><span class="line"># 本地接口</span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line"># 广域网接口</span><br><span class="line">allow-hotplug enp1s0</span><br><span class="line"></span><br><span class="line"># 局域网接口</span><br><span class="line">auto br0</span><br><span class="line">allow-hotplug br0</span><br><span class="line">iface br0 inet static</span><br><span class="line">      address 192.168.2.1</span><br><span class="line">      network 192.168.2.0</span><br><span class="line">      netmask 255.255.255.0</span><br><span class="line">      brocast 192.168.2.255</span><br><span class="line">      bridge-ports enp2s0 enp3s0 enp4s0</span><br><span class="line">      </span><br><span class="line"># PPPoE 接口，由 pppoeconf 自动生成</span><br><span class="line">auto dsl-provider</span><br><span class="line">iface dsl-provider inet ppp</span><br><span class="line">pre-up /bin/ip link set enp1s0 up # line maintained by pppoeconf</span><br><span class="line">provider dsl-provider</span><br><span class="line">iface enp1s0 inet manual</span><br></pre></td></tr></table></figure><p>这里是我的的软路由的接口配置，可以看到出口网卡是 enp1s0，我会通过这个网卡进行 PPPoE 拨号上网。这个配置最后的 <code>dsl-provider</code> 是由 pppoeconf 自动生成的，我们之后会讲到。</p><p>请注意，在这里不要配置 DHCP 连接，不然内置的  dhclient 会和之后我们用到的 <code>wide-dhcpv6-client</code> 冲突。</p><p>因为我们是要配置软路由，所以我们需要启用 IPv6 转发。</p><p>在  <code>/etc/sysctl.conf</code> 添加上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">net.ipv6.conf.all.forwarding=2</span><br><span class="line">net.ipv6.conf.default.forwarding=2</span><br><span class="line"></span><br><span class="line">net.ipv6.conf.all.accept_ra=2</span><br><span class="line">net.ipv6.conf.default.accept_ra=2</span><br><span class="line"></span><br><span class="line">net.ipv6.conf.all.use_tempaddr=2</span><br><span class="line">net.ipv6.conf.default.use_tempaddr=2</span><br></pre></td></tr></table></figure><p>我们通过设置: <code>net.ipv6.conf.all.forwarding=2</code> 和 <code>net.ipv6.conf.default.forwarding=2</code> 启用了 IPv6 转发，但是根据注释：</p><blockquote><p>Uncomment the next line to enable packet forwarding for IPv6</p><p>Enabling this option disables Stateless Address Autoconfiguration</p><p>based on Router Advertisements for this host</p></blockquote><p>开启了这个选项之后，系统将不会进行 RA 处理，也就是我们的广域网将不会有 IPv6 地址，所以我们这里手动设置了：<code>net.ipv6.conf.all.accept_ra=2</code> 和 <code>net.ipv6.conf.default.accept_ra=2</code> 来启用 RA 处理。</p><p>最后两行是启用 IPv6 的隐私扩展，具体可以阅读 Arch Wiki 的相关<a href="https://wiki.archlinux.org/index.php/IPv6_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">介绍</a>。</p><p>因为 RA 是 ICMPv6 报文，所以我们要在防火墙上允许 ICMPv6 的通过。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p ipv6-icmp -j ACCEPT</span><br><span class="line">iptables -A FORWARD -p ipv6-icmp -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -p ipv6-icmp -j ACCEPT</span><br><span class="line">ip6tables -A INPUT -p ipv6-icmp -j ACCEPT</span><br><span class="line">ip6tables -A FORWARD -p ipv6-icmp -j ACCEPT</span><br><span class="line">ip6tables -A OUTPUT -p ipv6-icmp -j ACCEPT</span><br></pre></td></tr></table></figure><p>接下来我们来配置 PPPoE 上网，运行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install pppoeconf</span><br></pre></td></tr></table></figure><p>在安装 <code>pppoeconf</code> 的时候会自动安装 <code>pppd</code>，<code>pppoeconf</code> 是个帮助你配置 <code>pppd</code> 的小工具，安装完成后输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pppoeconf</span><br></pre></td></tr></table></figure><p>然后按照指示输入你宽带的账号密码，如果其他选项的含义不清楚请选择默认，在配置成功后，你可以通过: <code>poff</code>，<code>pon</code> 和 <code> plog</code>，来关闭、开启 PPoE 以及显示 log。</p><p>但是在默认的情况下，<code>pppoeconf</code> 自动生成的配置文件不会启用 IPv6，我们还需要对配置文件进行一些修改。</p><p>配置文件在 <code>/etc/ppp/peers/</code> 目录下，我这里自动生成的是 <code>dsl-provider</code>。</p><p><code>/etc/ppp/peers/dsl-provider</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">noipdefault</span><br><span class="line">defaultroute</span><br><span class="line">replacedefaultroute</span><br><span class="line">hide-password</span><br><span class="line">noauth</span><br><span class="line">persist</span><br><span class="line">persist</span><br><span class="line">maxfail 0</span><br><span class="line">plugin rp-pppoe.so</span><br><span class="line">nic-enp1s0</span><br><span class="line">user &quot;宽带账号&quot;</span><br><span class="line">usepeerdns</span><br><span class="line">+ipv6</span><br><span class="line">debug</span><br></pre></td></tr></table></figure><p>这里我在末尾添加上了<code>+ipv6</code>，请注意加号，其次我还添加上了 <code>debug</code>，用于之后使用 <code>plog</code> 来 Debug 问题，此时你重新启动 PPPoE，然后输入 <code>ip addr show ppp0</code>，观察 <code>ppp0</code> 接口应该就能看到分配的 IPv6 地址了，因为我们启用了隐私扩展，所以你能看到有两个 IPv6 地址。</p><p><img src="/./ppp0.jpeg" alt="ppp0"></p><p>接下来我们需要给内网设备也分配对应的 IPv6 地址。这里我们用到了 Prefix delegation（<a href="https://zh.wikipedia.org/wiki/%E5%89%8D%E7%BC%80%E4%BB%A3%E7%90%86">前缀代理</a>），简称 PD。简单来说就是我们向我们的上级路由发送 PD 请求，上级路由会分给我们一个前缀长度小于等于64的网段，然后我们就能将个网段划分成一个或者一些 &#x2F;64 的网段接着向局域网内的设备分配，此时局域网内的设备的上级路由就是我们的网关。</p><p>这里有个需要注意的地方，我们向局域网设备分配的 IP 地址也是公网地址，而不是 IPv4 时代的私有地址，不过因为上级路由是我们的网关，所以这些设备其实是在一个局域网内，并且因为这些地址都是公网地址，所以我们不需要做 NAT 转化的操作。</p><p>为了实现这个功能，我们需要使用 <code>wide-dhcpv6-client</code>。</p><p>首先安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install wide-dhcpv6-client</span><br></pre></td></tr></table></figure><p>在安装完成后，我们需要配置 PD。</p><p>编辑：<code>/etc/wide-dhcpv6/dhcp6c.conf</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface ppp0 &#123;</span><br><span class="line">  send ia-pd 0;</span><br><span class="line">&#125;;</span><br><span class="line">id-assoc pd 0 &#123;</span><br><span class="line">  # use the interface connected to your LAN</span><br><span class="line">  prefix-interface br0 &#123;</span><br><span class="line">    sla-id 1;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这段配置来自 <a href="https://github.com/jinmei/wide-dhcpv6/blob/master/dhcp6c.conf.sample">Github</a>，其中的 <code>ppp0</code> 应该是你广域网的接口，而 <code>br0</code> 应该是你局域网的接口。</p><p>另外我们为了要使用Prefix delegation，要给你的防火墙<a href="https://www.iit-training.com/blog/2013/02/ipv6-prefix-delegation-and-firewall-rules">放行546&#x2F;udp端口</a>，这一部分放行请按照你使用的防火墙软件自行决定。</p><p>这里非常感谢 Rio 提供的一个新的现代化的 DHCP6c System Service 用来替换自带的 <code>wide-dhcpv6-client.service</code> 。</p><p>添加到 <code>/etc/systemd/system/dhcp6c.service</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=WIDE DHCPv6 Client</span><br><span class="line">Wants=network-online.target</span><br><span class="line">After=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/sbin/dhcp6c -f ppp0</span><br><span class="line">ExecReload=/bin/kill -HUP $MAINPID</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=3</span><br><span class="line">NoNewPrivileges=yes</span><br><span class="line">PrivateTmp=yes</span><br><span class="line">ProtectHome=yes</span><br><span class="line">ProtectSystem=strict</span><br><span class="line">ReadWritePaths=/run/ /var/log/</span><br><span class="line">ProtectKernelTunables=yes</span><br><span class="line">ProtectControlGroups=yes</span><br><span class="line">SystemCallFilter=~@mount</span><br><span class="line">SystemCallArchitectures=native</span><br><span class="line">LockPersonality=yes</span><br><span class="line">MemoryDenyWriteExecute=yes</span><br><span class="line">RestrictRealtime=yes</span><br><span class="line">RemoveIPC=yes</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>然后运行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop wide-dhcpv6-client.service</span><br><span class="line">systemctl disable wide-dhcpv6-client.service</span><br><span class="line">systemctl enable dhcp6c.service</span><br></pre></td></tr></table></figure><p>你就可以通过 <code>dhcp6c.service</code> 来控制 <code>wide-dhcpv6-client</code> 了。</p><p>运行成功后，观察你局域网的接口，应该就能看到对应分配的地址了。</p><p><img src="/2020/11/11/x86-soft-router-and-ipv6/lan.jpeg" alt="lan"></p><p>最后需要向局域网设备发送 RA ，使用 slaac 来分配IP地址，这里我们使用了 Dnsmasq，因为 Dnsmasq 是个非常常用的软件，就不多介绍了，在 Dnsmasq 的配置文件里加上:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enable-ra</span><br><span class="line">dhcp-range=::,constructor:br0,ra-only,slaac</span><br></pre></td></tr></table></figure><p><code>br0</code> 填入你的局域网接口。</p><p>这时你的局域网设备应该也能分配到全球唯一的 IPv6 地址了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景故事&quot;&gt;&lt;a href=&quot;#背景故事&quot; class=&quot;headerlink&quot; title=&quot;背景故事&quot;&gt;&lt;/a&gt;背景故事&lt;/h2&gt;&lt;p&gt;这一次踩坑之旅的起源是一段来自内核恐慌 Telegram 群的关于 IPv6 的讨论，&lt;a href=&quot;https://tw</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>如何写一个教程</title>
    <link href="http://blog.otakusaikou.com/2020/11/05/how-to-write-a-tutorial/"/>
    <id>http://blog.otakusaikou.com/2020/11/05/how-to-write-a-tutorial/</id>
    <published>2020-11-05T12:19:08.000Z</published>
    <updated>2023-04-15T01:24:06.263Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着社区人数的增加，各种相关教程的数量也开始增长，但是就我的观察而言，很多教程并没有做到基本的可读性与可访问性。而这篇文章的目的就是介绍如何做出基本美观的教程。当然在这篇文章我不会提及如何创作教程内容，这篇文章的主要关注点是，教程创作的流程、部署以及发布。</p><h2 id="可读性和可访问性"><a href="#可读性和可访问性" class="headerlink" title="可读性和可访问性"></a>可读性和可访问性</h2><p>首先要回答到是，什么是可读性和可访问性。我们先从可读性开始说明，可读性包括很多的方面：字体排版、网页的配色等。要一一说明显然是不现实的，这里我们就用一个例子说明。</p><p><img src="/2020/11/05/how-to-write-a-tutorial/image-20201105123703489.png" alt="image-20201105123703489"></p><p><img src="/2020/11/05/how-to-write-a-tutorial/image-20201105123738827.png" alt="image-20201105123738827"></p><p>这是同一段文本经过不同的排版方式后呈现出来的效果，我相信经过这个对比，应该很容易体会出为什么是什么可读性，以及为什么可读性是重要的。</p><p>接下来，是可访问性，你应该优先把教程作为一个的网页进行发布，而不是通过例如：加密的百度网盘分享一个 docx，来分发你的教程。</p><p>我们就以「加密的百度网盘分享一个 的 docx」作为例子，来说一下为什么这个是一种不好的方法。</p><p>首先加密的百度网盘就意味的一件事，这个教程是难以传播的，先不论如果通过百度网盘访问你的教程，还需要下载文件（并且忍受缓慢的速度），光是访问需要输入密码这件事，其实就是在减少你的教程的访问数量。</p><p>其次我们来讲一下分发 docx 文件为什么不好，你得先明确一点，docx 是 Microsoft Office 的格式而 Minecraft 是个跨平台的游戏，你的读者不是一定只是 Windows 用户，也可以是 macOS 和 Linux 用户，哪怕是 Windows 用户，也不一定就买了 Office，这一点就决定了对于他们来说打开 docx 其实并不是一件非常方便的事情。另外用 docx 来分发你的教程，如果你的教程需要持续更新，读者也需要不时的重新下载一遍，这个显然是不可取的。</p><p>有的作者可能会选择将自己的教程内容直接发布在某个论坛之上。但是这其实也不是一个非常好的办法，因为不同的论坛有不同的规定，你的教程很有可能在某天就变得无法访问了，这相当于将你的教程拱手送给了论坛。</p><p>而一个单独的网页则没有以上的问题，读者只需要输入地址即可访问，也不需要不断的重复下载一个文件，而且你可以自己控制网页的样式，并且可以做到自动化：在每次更新之后只要经过简单的步骤就可以更新对应的网页。</p><h2 id="撰写"><a href="#撰写" class="headerlink" title="撰写"></a>撰写</h2><p>你可以使用 <a href="https://zh.wikipedia.org/wiki/Markdown">Markdown</a> 作为你的写作格式，一切根据你需要来，有些作者可能会更加习惯 LaTex 等格式。关于 Markdown 的语法，这里就不多加说明了，非常容易学习。之后你得选定一个网页生成器，对于长篇的教程来说，合适的工具是各种电子书生成器，比如 <a href="https://github.com/rust-lang/mdBook">mdbook</a>（可能有的作者会使用 GitBook，但是 Gitbook 这个项目已经停止更新了，请不要使用了）。</p><p>接下来你就可以通过这些工具，写出一个精美的教程了。</p><h2 id="构建与发布"><a href="#构建与发布" class="headerlink" title="构建与发布"></a>构建与发布</h2><p>在你写了一定内容的教程之后，你接下来面临的一个问题就是如何发布你的教程，这里推荐使用 <a href="https://pages.github.com/">Github Pages</a> 的功能，你不需要有自己的域名和服务器，可以直接发布静态网页。当然，很多作者可能会将教程在本地构建完成，然后再通过 Git 同步到 Github 仓库上，但这其实不是一种好的方式，构建工作应该自动进行。你可以通过类似 <a href="https://github.com/features/actions">Github Action</a> 这样的工具，自动的构建与发布你的教程，这里是 Neutrino 的<a href="https://github.com/FledgeXu/Neutrino/blob/master/.github/workflows/deploy.yaml">例子</a>。</p><p>最后呈现出来的效果是，我只要修改好内容，然后向 Github push 修改好的内容，对应的网站会自动的更新与发布。</p><h2 id="一些额外事项"><a href="#一些额外事项" class="headerlink" title="一些额外事项"></a>一些额外事项</h2><p>在开始写作一个教程的时候，你需要选择一个合适的许可证，这个许可证会在一定程度上保护你的权利，这里建议使用 <a href="https://creativecommons.org/">Creative Commons</a> 系列许可证。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;随着社区人数的增加，各种相关教程的数量也开始增长，但是就我的观察而言，很多教程并没有做到基本的可读性与可访问性。而这篇文章的目的就是介绍如何</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>专业分工是给昆虫准备的</title>
    <link href="http://blog.otakusaikou.com/2020/11/02/specialization-is-for-insects/"/>
    <id>http://blog.otakusaikou.com/2020/11/02/specialization-is-for-insects/</id>
    <published>2020-11-02T14:53:13.000Z</published>
    <updated>2023-04-15T01:24:06.267Z</updated>
    
    <content type="html"><![CDATA[<p>仔细想想，这个博客需要有一个类似于「发刊词」一样的东西。当然不需要什么非常正式的发刊词，而是某种可以表明某种「觉悟」的东西。想了想用了这么一个标题：「专业分工是给昆虫准备的」。这个这句话其实是来自科幻小说家 <a href="https://en.wikipedia.org/wiki/Robert_A._Heinlein">Robert Heinlein</a> 的名言：</p><blockquote><p>“A human being should be able to change a diaper, plan an invasion, butcher a hog, conn a ship, design a building, write a sonnet, balance accounts, build a wall, set a bone, comfort the dying, take orders, give orders, cooperate, act alone, solve equations, analyze a new problem, pitch manure, program a computer, cook a tasty meal, fight efficiently, die gallantly. Specialization is for insects.”</p></blockquote><p>我本人其实并没有读过 Heinlein 的小说，这段话也是从李如一先生的<a href="https://blog.yitianshijie.net/2016/12/19/a-revolutionary-catalog/">博客</a>上读到的。但这段话确实象征了某些东西，某些对我而言非常重要觉悟。这个觉悟大概是我们要追求「完整性」，追求成为一个完整的人。</p><p>而这个博客里的内容自然也会非常广泛，只要我感兴趣的事物，估计都会有所涉猎。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;仔细想想，这个博客需要有一个类似于「发刊词」一样的东西。当然不需要什么非常正式的发刊词，而是某种可以表明某种「觉悟」的东西。想了想用了这么一个标题：「专业分工是给昆虫准备的」。这个这句话其实是来自科幻小说家 &lt;a href=&quot;https://en.wikipedia.org</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>你好世界</title>
    <link href="http://blog.otakusaikou.com/2020/11/02/Hello-Wolrd/"/>
    <id>http://blog.otakusaikou.com/2020/11/02/Hello-Wolrd/</id>
    <published>2020-11-02T14:16:19.000Z</published>
    <updated>2023-04-15T01:24:06.259Z</updated>
    
    <content type="html"><![CDATA[<p>看起来 Hexo 必须要有一篇文章才会生成 <code>index.htm</code>，那么我就创建这一篇文章作为占位符吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;看起来 Hexo 必须要有一篇文章才会生成 &lt;code&gt;index.htm&lt;/code&gt;，那么我就创建这一篇文章作为占位符吧。&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
